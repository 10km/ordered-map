<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ordered-map: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ordered-map
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">ordered-map Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="https://travis-ci.org/Tessil/ordered-map"></a> <a href="https://ci.appveyor.com/project/Tessil/ordered-map/branch/master"></a></p>
<h2>C++ hash map and hash set which preserves the order of insertion</h2>
<p>The ordered-map library provides a hash map and a hash set which preserve the order of insertion in a way similar to Python's <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict">OrderedDict</a>. When iterating over the map, the values will be returned in the same order as they were inserted.</p>
<p>The values are stored contiguously in an underlying structure, no holes in-between values even after an erase operation. By default a <code>std::deque</code> is used for this structure, but it's also possible to use a <code>std::vector</code>. This structure is directly accessible through the <code>values_container()</code> method and if the structure is a <code>std::vector</code>, a <code>data()</code> method is also provided to easily interact with C APIs.</p>
<p>To resolve collisions on hashes, the library uses linear robin hood probing with backward shift deletion.</p>
<p>The library provides a behaviour similar to a <code>std::deque/std::vector</code> with unique values but with an average time complexity of O(1) for lookups and an amortised time complexity of O(1) for insertions. This comes at the price of a little higher memory footprint (8 bytes per bucket by default).</p>
<p>Two classes are provided: <code><a class="el" href="classtsl_1_1ordered__map.html">tsl::ordered_map</a></code> and <code><a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a></code>.</p>
<p><b>Note</b>: The library uses a power of two for the size of its buckets array to take advantage of the <a href="https://en.wikipedia.org/wiki/Modulo_operation#Performance_issues">fast modulo</a>. For good performances, it requires the hash table to have a well-distributed hash function. If you encounter performance issues check your hash function.</p>
<h3>Key features</h3>
<ul>
<li>Header-only library, just add the <a href="include/">include</a> directory to your include path and you are ready to go. If you use CMake, you can also use the <code><a class="el" href="classtsl_1_1ordered__map.html">tsl::ordered_map</a></code> exported target from the <a href="CMakeLists.txt">CMakeLists.txt</a>.</li>
<li>Values are stored in the same order as the insertion order. The library provides a direct access to the underlying structure which stores the values.</li>
<li>O(1) average time complexity for lookups with performances similar to <code>std::unordered_map</code> but with faster insertions and reduced memory usage (see <a href="https://tessil.github.io/2016/08/29/benchmark-hopscotch-map.html">benchmark</a> for details).</li>
<li>Provide random access iterators and also reverse iterators.</li>
<li>Support for heterogeneous lookups allowing the usage of <code>find</code> with a type different than <code>Key</code> (e.g. if you have a map that uses <code>std::unique_ptr&lt;foo&gt;</code> as key, you can use a <code>foo*</code> or a <code>std::uintptr_t</code> as key parameter to <code>find</code> without constructing a <code>std::unique_ptr&lt;foo&gt;</code>, see <a href="#heterogeneous-lookups">example</a>).</li>
<li>If the hash is known before a lookup, it is possible to pass it as parameter to speed-up the lookup (see <code>precalculated_hash</code> parameter in <a href="https://tessil.github.io/ordered-map/classtsl_1_1ordered__map.html#a7fcde27edc6697a0b127f4b1aefa8a7d">API</a>).</li>
<li>Support for efficient serialization and deserialization (see <a href="#serialization">example</a> and the <code>serialize/deserialize</code> methods in the <a href="https://tessil.github.io/ordered-map/classtsl_1_1ordered__map.html">API</a> for details).</li>
<li>The library can be used with exceptions disabled (through <code>-fno-exceptions</code> option on Clang and GCC, without an <code>/EH</code> option on MSVC or simply by defining <code>TSL_NO_EXCEPTIONS</code>). <code>std::terminate</code> is used in replacement of the <code>throw</code> instruction when exceptions are disabled.</li>
<li>API closely similar to <code>std::unordered_map</code> and <code>std::unordered_set</code>.</li>
</ul>
<h3>Differences compared to <code>std::unordered_map</code></h3>
<p><code><a class="el" href="classtsl_1_1ordered__map.html">tsl::ordered_map</a></code> tries to have an interface similar to <code>std::unordered_map</code>, but some differences exist.</p><ul>
<li>The iterators are <code>RandomAccessIterator</code>.</li>
<li>Iterator invalidation behaves in a way closer to <code>std::vector</code> and <code>std::deque</code> (see <a href="https://tessil.github.io/ordered-map/classtsl_1_1ordered__map.html#details">API</a> for details). If you use <code>std::vector</code> as <code>ValueTypeContainer</code>, you can use <code>reserve()</code> to preallocate some space and avoid the invalidation of the iterators on insert.</li>
<li>Slow <code>erase()</code> operation, it has a complexity of O(n). A faster O(1) version <code>unordered_erase()</code> exists, but it breaks the insertion order (see <a href="https://tessil.github.io/ordered-map/classtsl_1_1ordered__map.html#a9f94a7889fa7fa92eea41ca63b3f98a4">API</a> for details). An O(1) <code>pop_back()</code> is also available.</li>
<li>The equality oprators <code>operator==</code> and <code>operator!=</code> are order dependent. Two <code><a class="el" href="classtsl_1_1ordered__map.html">tsl::ordered_map</a></code> with the same values but inserted in a different order don't compare equal.</li>
<li>For iterators, <code>operator*()</code> and <code>operator-&gt;()</code> return a reference and a pointer to <code>const std::pair&lt;Key, T&gt;</code> instead of <code>std::pair&lt;const Key, T&gt;</code> making the value <code>T</code> not modifiable. To modify the value you have to call the <code>value()</code> method of the iterator to get a mutable reference. Example: <div class="fragment"><div class="line">{c++}</div><div class="line">tsl::ordered_map&lt;int, int&gt; map = {{1, 1}, {2, 1}, {3, 1}};</div><div class="line">for(auto it = map.begin(); it != map.end(); ++it) {</div><div class="line">    //it-&gt;second = 2; // Illegal</div><div class="line">    it.value() = 2; // Ok</div><div class="line">}</div></div><!-- fragment --></li>
<li>By default the map can only hold up to 2<sup>32</sup> - 1 values, that is 4 294 967 295 values. This can be raised through the <code>IndexType</code> class template parameter, check the <a href="https://tessil.github.io/ordered-map/classtsl_1_1ordered__map.html#details">API</a> for details.</li>
<li>No support for some bucket related methods (like <code>bucket_size</code>, <code>bucket</code>, ...).</li>
</ul>
<p>Thread-safety guarantee is the same as <code>std::unordered_map</code> (i.e. possible to have multiple concurrent readers with no writer).</p>
<p>Concerning the strong exception guarantee, it holds only if <code>ValueContainer::emplace_back</code> has the strong exception guarantee (which is true for <code>std::vector</code> and <code>std::deque</code> as long as the type <code>T</code> is not a move-only type with a move constructor that may throw an exception, see <a href="http://en.cppreference.com/w/cpp/container/vector/emplace_back#Exceptions">details</a>).</p>
<p>These differences also apply between <code>std::unordered_set</code> and <code><a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a></code>.</p>
<h3>Installation</h3>
<p>To use ordered-map, just add the <a href="include/">include</a> directory to your include path. It is a <b>header-only</b> library.</p>
<p>If you use CMake, you can also use the <code><a class="el" href="classtsl_1_1ordered__map.html">tsl::ordered_map</a></code> exported target from the <a href="CMakeLists.txt">CMakeLists.txt</a> with <code>target_link_libraries</code>. </p><div class="fragment"><div class="line"># Example where the ordered-map project is stored in a third-party directory</div><div class="line">add_subdirectory(third-party/ordered-map)</div><div class="line">target_link_libraries(your_target PRIVATE tsl::ordered_map)  </div></div><!-- fragment --><p>If the project has been installed through <code>make install</code>, you can also use <code>find_package(tsl-ordered-map REQUIRED)</code> instead of <code>add_subdirectory</code>.</p>
<p>The code should work with any C++11 standard-compliant compiler and has been tested with GCC 4.8.4, Clang 3.5.0 and Visual Studio 2015.</p>
<p>To run the tests you will need the Boost Test library and CMake.</p>
<div class="fragment"><div class="line">git clone https://github.com/Tessil/ordered-map.git</div><div class="line">cd ordered-map/tests</div><div class="line">mkdir build</div><div class="line">cd build</div><div class="line">cmake ..</div><div class="line">cmake --build .</div><div class="line">./tsl_ordered_map_tests </div></div><!-- fragment --><h3>Usage</h3>
<p>The API can be found <a href="https://tessil.github.io/ordered-map/">here</a>.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">{c++}</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;cstdlib&gt;</div><div class="line">#include &lt;tsl/ordered_map.h&gt;</div><div class="line">#include &lt;tsl/ordered_set.h&gt;</div><div class="line"></div><div class="line">int main() {</div><div class="line">    tsl::ordered_map&lt;char, int&gt; map = {{&#39;d&#39;, 1}, {&#39;a&#39;, 2}, {&#39;g&#39;, 3}};</div><div class="line">    map.insert({&#39;b&#39;, 4});</div><div class="line">    map[&#39;h&#39;] = 5;</div><div class="line">    map[&#39;e&#39;] = 6;</div><div class="line"></div><div class="line">    map.erase(&#39;a&#39;);</div><div class="line"></div><div class="line"></div><div class="line">    // {d, 1} {g, 3} {b, 4} {h, 5} {e, 6}</div><div class="line">    for(const auto&amp; key_value : map) {</div><div class="line">        std::cout &lt;&lt; &quot;{&quot; &lt;&lt; key_value.first &lt;&lt; &quot;, &quot; &lt;&lt; key_value.second &lt;&lt; &quot;}&quot; &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    map.unordered_erase(&#39;b&#39;);</div><div class="line"></div><div class="line">    // Break order: {d, 1} {g, 3} {e, 6} {h, 5}</div><div class="line">    for(const auto&amp; key_value : map) {</div><div class="line">        std::cout &lt;&lt; &quot;{&quot; &lt;&lt; key_value.first &lt;&lt; &quot;, &quot; &lt;&lt; key_value.second &lt;&lt; &quot;}&quot; &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    for(auto it = map.begin(); it != map.end(); ++it) {</div><div class="line">        //it-&gt;second += 2; // Not valid.</div><div class="line">        it.value() += 2;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    if(map.find(&#39;d&#39;) != map.end()) {</div><div class="line">        std::cout &lt;&lt; &quot;Found &#39;d&#39;.&quot; &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    const std::size_t precalculated_hash = std::hash&lt;char&gt;()(&#39;d&#39;);</div><div class="line">    // If we already know the hash beforehand, we can pass it as argument to speed-up the lookup.</div><div class="line">    if(map.find(&#39;d&#39;, precalculated_hash) != map.end()) {</div><div class="line">        std::cout &lt;&lt; &quot;Found &#39;d&#39; with hash &quot; &lt;&lt; precalculated_hash &lt;&lt; &quot;.&quot; &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    tsl::ordered_set&lt;char, std::hash&lt;char&gt;, std::equal_to&lt;char&gt;,</div><div class="line">                     std::allocator&lt;char&gt;, std::vector&lt;char&gt;&gt; set;</div><div class="line">    set.reserve(6);</div><div class="line"></div><div class="line">    set = {&#39;3&#39;, &#39;4&#39;, &#39;9&#39;, &#39;2&#39;};</div><div class="line">    set.erase(&#39;2&#39;);</div><div class="line">    set.insert(&#39;1&#39;);</div><div class="line">    set.insert(&#39;\0&#39;);</div><div class="line"></div><div class="line">    set.pop_back();</div><div class="line">    set.insert({&#39;0&#39;, &#39;\0&#39;});</div><div class="line"></div><div class="line">    // Get raw buffer for C API: 34910</div><div class="line">    std::cout &lt;&lt; atoi(set.data()) &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><h4>Heterogeneous lookup</h4>
<p>Heterogeneous overloads allow the usage of other types than <code>Key</code> for lookup and erase operations as long as the used types are hashable and comparable to <code>Key</code>.</p>
<p>To activate the heterogeneous overloads in <code><a class="el" href="classtsl_1_1ordered__map.html">tsl::ordered_map</a>/set</code>, the qualified-id <code>KeyEqual::is_transparent</code> must be valid. It works the same way as for <a href="http://en.cppreference.com/w/cpp/container/map/find"><code>std::map::find</code></a>. You can either use <a href="http://en.cppreference.com/w/cpp/utility/functional/equal_to_void"><code>std::equal_to&lt;&gt;</code></a> or define your own function object.</p>
<p>Both <code>KeyEqual</code> and <code>Hash</code> will need to be able to deal with the different types.</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">#include &lt;functional&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;tsl/ordered_map.h&gt;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">struct employee {</div><div class="line">    employee(int id, std::string name) : m_id(id), m_name(std::move(name)) {</div><div class="line">    }</div><div class="line"></div><div class="line">    // Either we include the comparators in the class and we use `std::equal_to&lt;&gt;`...</div><div class="line">    friend bool operator==(const employee&amp; empl, int empl_id) {</div><div class="line">        return empl.m_id == empl_id;</div><div class="line">    }</div><div class="line"></div><div class="line">    friend bool operator==(int empl_id, const employee&amp; empl) {</div><div class="line">        return empl_id == empl.m_id;</div><div class="line">    }</div><div class="line"></div><div class="line">    friend bool operator==(const employee&amp; empl1, const employee&amp; empl2) {</div><div class="line">        return empl1.m_id == empl2.m_id;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    int m_id;</div><div class="line">    std::string m_name;</div><div class="line">};</div><div class="line"></div><div class="line">// ... or we implement a separate class to compare employees.</div><div class="line">struct equal_employee {</div><div class="line">    using is_transparent = void;</div><div class="line"></div><div class="line">    bool operator()(const employee&amp; empl, int empl_id) const {</div><div class="line">        return empl.m_id == empl_id;</div><div class="line">    }</div><div class="line"></div><div class="line">    bool operator()(int empl_id, const employee&amp; empl) const {</div><div class="line">        return empl_id == empl.m_id;</div><div class="line">    }</div><div class="line"></div><div class="line">    bool operator()(const employee&amp; empl1, const employee&amp; empl2) const {</div><div class="line">        return empl1.m_id == empl2.m_id;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line">struct hash_employee {</div><div class="line">    std::size_t operator()(const employee&amp; empl) const {</div><div class="line">        return std::hash&lt;int&gt;()(empl.m_id);</div><div class="line">    }</div><div class="line"></div><div class="line">    std::size_t operator()(int id) const {</div><div class="line">        return std::hash&lt;int&gt;()(id);</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line">int main() {</div><div class="line">    // Use std::equal_to&lt;&gt; which will automatically deduce and forward the parameters</div><div class="line">    tsl::ordered_map&lt;employee, int, hash_employee, std::equal_to&lt;&gt;&gt; map; </div><div class="line">    map.insert({employee(1, &quot;John Doe&quot;), 2001});</div><div class="line">    map.insert({employee(2, &quot;Jane Doe&quot;), 2002});</div><div class="line">    map.insert({employee(3, &quot;John Smith&quot;), 2003});</div><div class="line"></div><div class="line">    // John Smith 2003</div><div class="line">    auto it = map.find(3);</div><div class="line">    if(it != map.end()) {</div><div class="line">        std::cout &lt;&lt; it-&gt;first.m_name &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    map.erase(1);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    // Use a custom KeyEqual which has an is_transparent member type</div><div class="line">    tsl::ordered_map&lt;employee, int, hash_employee, equal_employee&gt; map2;</div><div class="line">    map2.insert({employee(4, &quot;Johnny Doe&quot;), 2004});</div><div class="line"></div><div class="line">    // 2004</div><div class="line">    std::cout &lt;&lt; map2.at(4) &lt;&lt; std::endl;</div><div class="line">} </div></div><!-- fragment --><h4>Serialization</h4>
<p>The library provides an efficient way to serialize and deserialize a map or a set so that it can be saved to a file or send through the network. To do so, it requires the user to provide a function object for both serialization and deserialization.</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">struct serializer {</div><div class="line">    // Must support the following types for U: std::uint64_t, float </div><div class="line">    // and std::pair&lt;Key, T&gt; if a map is used or Key for a set.</div><div class="line">    template&lt;typename U&gt;</div><div class="line">    void operator()(const U&amp; value);</div><div class="line">};</div></div><!-- fragment --><div class="fragment"><div class="line">{c++}</div><div class="line">struct deserializer {</div><div class="line">    // Must support the following types for U: std::uint64_t, float </div><div class="line">    // and std::pair&lt;Key, T&gt; if a map is used or Key for a set.</div><div class="line">    template&lt;typename U&gt;</div><div class="line">    U operator()();</div><div class="line">};</div></div><!-- fragment --><p>Note that the implementation leaves binary compatibilty (endianness, float binary representation, size of int, ...) of the types it serializes/deserializes in the hands of the provided function objects if compatibilty is required.</p>
<p>More details regarding the <code>serialize</code> and <code>deserialize</code> methods can be found in the <a href="https://tessil.github.io/ordered-map/classtsl_1_1ordered__map.html">API</a>.</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">#include &lt;cassert&gt;</div><div class="line">#include &lt;cstdint&gt;</div><div class="line">#include &lt;fstream&gt;</div><div class="line">#include &lt;type_traits&gt;</div><div class="line">#include &lt;tsl/ordered_map.h&gt;</div><div class="line"></div><div class="line"></div><div class="line">class serializer {</div><div class="line">public:</div><div class="line">    explicit serializer(const char* file_name) {</div><div class="line">        m_ostream.exceptions(m_ostream.badbit | m_ostream.failbit);</div><div class="line">        m_ostream.open(file_name, std::ios::binary);</div><div class="line">    }</div><div class="line"></div><div class="line">    template&lt;class T,</div><div class="line">             typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value&gt;::type* = nullptr&gt;</div><div class="line">    void operator()(const T&amp; value) {</div><div class="line">        m_ostream.write(reinterpret_cast&lt;const char*&gt;(&amp;value), sizeof(T));</div><div class="line">    }</div><div class="line"></div><div class="line">    void operator()(const std::pair&lt;std::int64_t, std::int64_t&gt;&amp; value) {</div><div class="line">        (*this)(value.first);</div><div class="line">        (*this)(value.second);</div><div class="line">    }</div><div class="line"></div><div class="line">private:</div><div class="line">    std::ofstream m_ostream;</div><div class="line">};</div><div class="line"></div><div class="line">class deserializer {</div><div class="line">public:</div><div class="line">    explicit deserializer(const char* file_name) {</div><div class="line">        m_istream.exceptions(m_istream.badbit | m_istream.failbit | m_istream.eofbit);</div><div class="line">        m_istream.open(file_name, std::ios::binary);</div><div class="line">    }</div><div class="line"></div><div class="line">    template&lt;class T&gt;</div><div class="line">    T operator()() {</div><div class="line">        T value;</div><div class="line">        deserialize(value);</div><div class="line"></div><div class="line">        return value;</div><div class="line">    }</div><div class="line"></div><div class="line">private:</div><div class="line">    template&lt;class T,</div><div class="line">             typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value&gt;::type* = nullptr&gt;</div><div class="line">    void deserialize(T&amp; value) {</div><div class="line">        m_istream.read(reinterpret_cast&lt;char*&gt;(&amp;value), sizeof(T));</div><div class="line">    }</div><div class="line"></div><div class="line">    void deserialize(std::pair&lt;std::int64_t, std::int64_t&gt;&amp; value) {</div><div class="line">        deserialize(value.first);</div><div class="line">        deserialize(value.second);</div><div class="line">    }</div><div class="line"></div><div class="line">private:</div><div class="line">    std::ifstream m_istream;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line">int main() {</div><div class="line">    const tsl::ordered_map&lt;std::int64_t, std::int64_t&gt; map = {{1, -1}, {2, -2}, {3, -3}, {4, -4}};</div><div class="line"></div><div class="line"></div><div class="line">    const char* file_name = &quot;ordered_map.data&quot;;</div><div class="line">    {</div><div class="line">        serializer serial(file_name);</div><div class="line">        map.serialize(serial);</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">        deserializer dserial(file_name);</div><div class="line">        auto map_deserialized = tsl::ordered_map&lt;std::int64_t, std::int64_t&gt;::deserialize(dserial);</div><div class="line"></div><div class="line">        assert(map == map_deserialized);</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">        deserializer dserial(file_name);</div><div class="line"></div><div class="line">        /**</div><div class="line">         * If the serialized and deserialized map are hash compatibles (see conditions in API), </div><div class="line">         * setting the argument to true speed-up the deserialization process as we don&#39;t have </div><div class="line">         * to recalculate the hash of each key. We also know how much space each bucket needs.</div><div class="line">         */</div><div class="line">        const bool hash_compatible = true;</div><div class="line">        auto map_deserialized = </div><div class="line">            tsl::ordered_map&lt;std::int64_t, std::int64_t&gt;::deserialize(dserial, hash_compatible);</div><div class="line"></div><div class="line">        assert(map == map_deserialized);</div><div class="line">    }</div><div class="line">} </div></div><!-- fragment --><h5>Serialization with Boost Serialization and compression with zlib</h5>
<p>It's possible to use a serialization library to avoid the boilerplate.</p>
<p>The following example uses Boost Serialization with the Boost zlib compression stream to reduce the size of the resulting serialized file. The example requires C++20 due to the usage of the template parameter list syntax in lambdas, but it can be adapted to less recent versions.</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">#include &lt;boost/archive/binary_iarchive.hpp&gt;</div><div class="line">#include &lt;boost/archive/binary_oarchive.hpp&gt;</div><div class="line">#include &lt;boost/iostreams/filter/zlib.hpp&gt;</div><div class="line">#include &lt;boost/iostreams/filtering_stream.hpp&gt;</div><div class="line">#include &lt;boost/serialization/split_free.hpp&gt;</div><div class="line">#include &lt;boost/serialization/utility.hpp&gt;</div><div class="line">#include &lt;cassert&gt;</div><div class="line">#include &lt;cstdint&gt;</div><div class="line">#include &lt;fstream&gt;</div><div class="line">#include &lt;tsl/ordered_map.h&gt;</div><div class="line"></div><div class="line"></div><div class="line">namespace boost { namespace serialization {</div><div class="line">    template&lt;class Archive, class Key, class T&gt;</div><div class="line">    void serialize(Archive &amp; ar, tsl::ordered_map&lt;Key, T&gt;&amp; map, const unsigned int version) {</div><div class="line">        split_free(ar, map, version); </div><div class="line">    }</div><div class="line"></div><div class="line">    template&lt;class Archive, class Key, class T&gt;</div><div class="line">    void save(Archive &amp; ar, const tsl::ordered_map&lt;Key, T&gt;&amp; map, const unsigned int /*version*/) {</div><div class="line">        auto serializer = [&amp;ar](const auto&amp; v) { ar &amp; v; };</div><div class="line">        map.serialize(serializer);</div><div class="line">    }</div><div class="line"></div><div class="line">    template&lt;class Archive, class Key, class T&gt;</div><div class="line">    void load(Archive &amp; ar, tsl::ordered_map&lt;Key, T&gt;&amp; map, const unsigned int /*version*/) {</div><div class="line">        auto deserializer = [&amp;ar]&lt;typename U&gt;() { U u; ar &amp; u; return u; };</div><div class="line">        map = tsl::ordered_map&lt;Key, T&gt;::deserialize(deserializer);</div><div class="line">    }</div><div class="line">}}</div><div class="line"></div><div class="line"></div><div class="line">int main() {</div><div class="line">    tsl::ordered_map&lt;std::int64_t, std::int64_t&gt; map = {{1, -1}, {2, -2}, {3, -3}, {4, -4}};</div><div class="line"></div><div class="line"></div><div class="line">    const char* file_name = &quot;ordered_map.data&quot;;</div><div class="line">    {</div><div class="line">        std::ofstream ofs;</div><div class="line">        ofs.exceptions(ofs.badbit | ofs.failbit);</div><div class="line">        ofs.open(file_name, std::ios::binary);</div><div class="line"></div><div class="line">        boost::iostreams::filtering_ostream fo;</div><div class="line">        fo.push(boost::iostreams::zlib_compressor());</div><div class="line">        fo.push(ofs);</div><div class="line"></div><div class="line">        boost::archive::binary_oarchive oa(fo);</div><div class="line"></div><div class="line">        oa &lt;&lt; map;</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">        std::ifstream ifs;</div><div class="line">        ifs.exceptions(ifs.badbit | ifs.failbit | ifs.eofbit);</div><div class="line">        ifs.open(file_name, std::ios::binary);</div><div class="line"></div><div class="line">        boost::iostreams::filtering_istream fi;</div><div class="line">        fi.push(boost::iostreams::zlib_decompressor());</div><div class="line">        fi.push(ifs);</div><div class="line"></div><div class="line">        boost::archive::binary_iarchive ia(fi);</div><div class="line"></div><div class="line">        tsl::ordered_map&lt;std::int64_t, std::int64_t&gt; map_deserialized;   </div><div class="line">        ia &gt;&gt; map_deserialized;</div><div class="line"></div><div class="line">        assert(map == map_deserialized);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h3>License</h3>
<p>The code is licensed under the MIT license, see the [LICENSE file](LICENSE) for details. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
