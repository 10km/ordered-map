<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ordered-map: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ordered-map
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">ordered-map Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="https://travis-ci.org/Tessil/ordered-map"></a> <a href="https://ci.appveyor.com/project/Tessil/ordered-map/branch/master"></a></p>
<h2>C++ hash map and hash set which preserves the order of insertion</h2>
<p>The ordered-map library provides a hash map and a hash set which preserve the order of insertion in a way similar to Python's <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict">OrderedDict</a>. When iterating over the map, the values will be returned in the same order as they were inserted.</p>
<p>The values are stored contiguously in an underlying structure, no holes in-between values even after an erase operation. By default a <code>std::deque</code> is used for this structure, but it's also possible to use a <code>std::vector</code>. This structure is directly accessible through the <code>values_container()</code> method and if the structure is a <code>std::vector</code>, a <code>data()</code> method is also provided to easily interact with C APIs.</p>
<p>To resolve collisions on hashes, the library uses robin hood probing with backward shift deletion.</p>
<p>The library provides a behaviour similar to a <code>std::deque/std::vector</code> with unique values but with an average time complexity of O(1) for lookups and an amortised time complexity of O(1) for insertions. This comes at the price of a little higher memory footprint (8 bytes per bucket by default).</p>
<p>Two classes are provided: <code><a class="el" href="classtsl_1_1ordered__map.html">tsl::ordered_map</a></code> and <code><a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a></code>.</p>
<p><b>Note</b>: The library uses a power of two for the size of its buckets array to take advantage of the <a href="https://en.wikipedia.org/wiki/Modulo_operation#Performance_issues">fast modulo</a>. For good performance, it requires the hash table to have a well-distributed hash function. If you encounter performance issues check your hash function.</p>
<h3>Key features</h3>
<ul>
<li>Header-only library, just add the project to your include path and you are ready to go.</li>
<li>Values are stored in the same order as the insertion order. The library provides a direct access to the underlying structure which stores the values.</li>
<li>O(1) average time complexity for lookups with performances similar to <code>std::unordered_map</code> but with faster insertions and reduced memory usage (see <a href="https://tessil.github.io/2016/08/29/benchmark-hopscotch-map.html">benchmark</a> for details).</li>
<li>Provide random access iterators and also reverse iterators.</li>
<li>Support for heterogeneous lookups (e.g. if you have a map that uses <code>std::unique_ptr&lt;int&gt;</code> as key, you could use an <code>int*</code> or a <code>std::uintptr_t</code> for example as key parameter for <code>find</code>, see <a href="#heterogeneous-lookup">example</a>).</li>
<li>If the hash is known before a lookup, it is possible to pass it as parameter to speed-up the lookup (see <a href="https://tessil.github.io/ordered-map/classtsl_1_1ordered__map.html#a7fcde27edc6697a0b127f4b1aefa8a7d">API</a>).</li>
<li>The library can be used with exceptions disabled (through <code>-fno-exceptions</code> option on Clang and GCC, without an <code>/EH</code> option on MSVC or simply by defining <code>TSL_NO_EXCEPTIONS</code>). <code>std::terminate</code> is used in replacement of the <code>throw</code> instruction when exceptions are disabled.</li>
<li>API closely similar to <code>std::unordered_map</code> and <code>std::unordered_set</code>.</li>
</ul>
<h3>Differences compare to <code>std::unordered_map</code></h3>
<p><code><a class="el" href="classtsl_1_1ordered__map.html">tsl::ordered_map</a></code> tries to have an interface similar to <code>std::unordered_map</code>, but some differences exist.</p><ul>
<li>The iterators are <code>RandomAccessIterator</code>.</li>
<li>Iterator invalidation behaves in a way closer to <code>std::vector</code> and <code>std::deque</code> (see <a href="https://tessil.github.io/ordered-map/classtsl_1_1ordered__map.html#details">API</a> for details). If you use <code>std::vector</code> as <code>ValueTypeContainer</code>, you can use <code>reserve()</code> to preallocate some space and avoid the invalidation of the iterators on insert.</li>
<li>Slow <code>erase()</code> operation, it has a complexity of O(n). A faster O(1) version <code>unordered_erase()</code> exists, but it breaks the insertion order (see <a href="https://tessil.github.io/ordered-map/classtsl_1_1ordered__map.html#a9f94a7889fa7fa92eea41ca63b3f98a4">API</a> for details). An O(1) <code>pop_back()</code> is also available.</li>
<li>For iterators, <code>operator*()</code> and <code>operator-&gt;()</code> return a reference and a pointer to <code>const std::pair&lt;Key, T&gt;</code> instead of <code>std::pair&lt;const Key, T&gt;</code> making the value <code>T</code> not modifiable. To modify the value you have to call the <code>value()</code> method of the iterator to get a mutable reference. Example: <div class="fragment"><div class="line">{c++}</div><div class="line">tsl::ordered_map&lt;int, int&gt; map = {{1, 1}, {2, 1}, {3, 1}};</div><div class="line">for(auto it = map.begin(); it != map.end(); ++it) {</div><div class="line">    //it-&gt;second = 2; // Illegal</div><div class="line">    it.value() = 2; // Ok</div><div class="line">}</div></div><!-- fragment --></li>
<li>By default the map can only hold up to 2<sup>32</sup> - 1 values, that is 4 294 967 295 values. This can be raised through the <code>IndexType</code> class template parameter, check the <a href="https://tessil.github.io/ordered-map/classtsl_1_1ordered__map.html#details">API</a> for details.</li>
<li>No support for some bucket related methods (like bucket_size, bucket, ...).</li>
</ul>
<p>Thread-safety guarantee is the same as <code>std::unordered_map</code> (i.e. possible to have multiple concurrent readers with no writer).</p>
<p>Concerning the strong exception guarantee, it holds only if <code>ValueContainer::emplace_back</code> has the strong exception guarantee (which is true for <code>std::vector</code> and <code>std::deque</code> as long as the type T is not a move-only type with a move constructor that may throw an exception, see <a href="http://en.cppreference.com/w/cpp/container/vector/emplace_back#Exceptions">details</a>).</p>
<p>These differences also apply between <code>std::unordered_set</code> and <code><a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a></code>.</p>
<h3>Installation</h3>
<p>To use the library, just add the project to your include path. It is a <b>header-only</b> library.</p>
<p>The code should work with any C++11 standard-compliant compiler and has been tested with GCC 4.8.4, Clang 3.5.0 and Visual Studio 2015.</p>
<p>To run the tests you will need the Boost Test library and CMake.</p>
<div class="fragment"><div class="line">git clone https://github.com/Tessil/ordered-map.git</div><div class="line">cd ordered-map</div><div class="line">mkdir build</div><div class="line">cd build</div><div class="line">cmake ..</div><div class="line">make</div><div class="line">./test_ordered_map</div></div><!-- fragment --><h3>Usage</h3>
<p>The API can be found <a href="https://tessil.github.io/ordered-map/">here</a>.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">{c++}</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;cstdlib&gt;</div><div class="line">#include &lt;tsl/ordered_map.h&gt;</div><div class="line">#include &lt;tsl/ordered_set.h&gt;</div><div class="line"></div><div class="line">int main() {</div><div class="line">    tsl::ordered_map&lt;char, int&gt; map = {{&#39;d&#39;, 1}, {&#39;a&#39;, 2}, {&#39;g&#39;, 3}};</div><div class="line">    map.insert({&#39;b&#39;, 4});</div><div class="line">    map[&#39;h&#39;] = 5;</div><div class="line">    map[&#39;e&#39;] = 6;</div><div class="line"></div><div class="line">    map.erase(&#39;a&#39;);</div><div class="line"></div><div class="line"></div><div class="line">    // {d, 1} {g, 3} {b, 4} {h, 5} {e, 6}</div><div class="line">    for(const auto&amp; key_value : map) {</div><div class="line">        std::cout &lt;&lt; &quot;{&quot; &lt;&lt; key_value.first &lt;&lt; &quot;, &quot; &lt;&lt; key_value.second &lt;&lt; &quot;}&quot; &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    map.unordered_erase(&#39;b&#39;);</div><div class="line"></div><div class="line">    // Break order: {d, 1} {g, 3} {e, 6} {h, 5}</div><div class="line">    for(const auto&amp; key_value : map) {</div><div class="line">        std::cout &lt;&lt; &quot;{&quot; &lt;&lt; key_value.first &lt;&lt; &quot;, &quot; &lt;&lt; key_value.second &lt;&lt; &quot;}&quot; &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    for(auto it = map.begin(); it != map.end(); ++it) {</div><div class="line">        //it-&gt;second += 2; // Not valid.</div><div class="line">        it.value() += 2;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    tsl::ordered_set&lt;char, std::hash&lt;char&gt;, std::equal_to&lt;char&gt;,</div><div class="line">                     std::allocator&lt;char&gt;, std::vector&lt;char&gt;&gt; set;</div><div class="line">    set.reserve(6);</div><div class="line"></div><div class="line">    set = {&#39;3&#39;, &#39;4&#39;, &#39;9&#39;, &#39;2&#39;};</div><div class="line">    set.erase(&#39;2&#39;);</div><div class="line">    set.insert(&#39;1&#39;);</div><div class="line">    set.insert(&#39;\0&#39;);</div><div class="line"></div><div class="line">    set.pop_back();</div><div class="line">    set.insert({&#39;0&#39;, &#39;\0&#39;});</div><div class="line"></div><div class="line">    // Get raw buffer for C API: 34910</div><div class="line">    std::cout &lt;&lt; atoi(set.data()) &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><h4>Heterogeneous lookup</h4>
<p>Heterogeneous overloads allow the usage of other types than <code>Key</code> for lookup and erase operations as long as the used types are hashable and comparable to <code>Key</code>.</p>
<p>To activate the heterogeneous overloads in <code><a class="el" href="classtsl_1_1ordered__map.html">tsl::ordered_map</a>/set</code>, the qualified-id <code>KeyEqual::is_transparent</code> must be valid. It works the same way as for <a href="http://en.cppreference.com/w/cpp/container/map/find"><code>std::map::find</code></a>. You can either use <a href="http://en.cppreference.com/w/cpp/utility/functional/equal_to_void"><code>std::equal_to&lt;&gt;</code></a> or define your own function object.</p>
<p>Both <code>KeyEqual</code> and <code>Hash</code> will need to be able to deal with the different types.</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">#include &lt;functional&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;tsl/ordered_map.h&gt;</div><div class="line"></div><div class="line"></div><div class="line">struct employee {</div><div class="line">    employee(int id, std::string name) : m_id(id), m_name(std::move(name)) {</div><div class="line">    }</div><div class="line"></div><div class="line">    friend bool operator==(const employee&amp; empl, int empl_id) {</div><div class="line">        return empl.m_id == empl_id;</div><div class="line">    }</div><div class="line"></div><div class="line">    friend bool operator==(int empl_id, const employee&amp; empl) {</div><div class="line">        return empl_id == empl.m_id;</div><div class="line">    }</div><div class="line"></div><div class="line">    friend bool operator==(const employee&amp; empl1, const employee&amp; empl2) {</div><div class="line">        return empl1.m_id == empl2.m_id;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    int m_id;</div><div class="line">    std::string m_name;</div><div class="line">};</div><div class="line"></div><div class="line">struct hash_employee {</div><div class="line">    std::size_t operator()(const employee&amp; empl) const {</div><div class="line">        return std::hash&lt;int&gt;()(empl.m_id);</div><div class="line">    }</div><div class="line"></div><div class="line">    std::size_t operator()(int id) const {</div><div class="line">        return std::hash&lt;int&gt;()(id);</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line">struct equal_employee {</div><div class="line">    using is_transparent = void;</div><div class="line"></div><div class="line">    bool operator()(const employee&amp; empl, int empl_id) const {</div><div class="line">        return empl.m_id == empl_id;</div><div class="line">    }</div><div class="line"></div><div class="line">    bool operator()(int empl_id, const employee&amp; empl) const {</div><div class="line">        return empl_id == empl.m_id;</div><div class="line">    }</div><div class="line"></div><div class="line">    bool operator()(const employee&amp; empl1, const employee&amp; empl2) const {</div><div class="line">        return empl1.m_id == empl2.m_id;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line">int main() {</div><div class="line">    // Use std::equal_to&lt;&gt; which will automatically deduce and forward the parameters</div><div class="line">    tsl::ordered_map&lt;employee, int, hash_employee, std::equal_to&lt;&gt;&gt; map; </div><div class="line">    map.insert({employee(1, &quot;John Doe&quot;), 2001});</div><div class="line">    map.insert({employee(2, &quot;Jane Doe&quot;), 2002});</div><div class="line">    map.insert({employee(3, &quot;John Smith&quot;), 2003});</div><div class="line"></div><div class="line">    // John Smith 2003</div><div class="line">    auto it = map.find(3);</div><div class="line">    if(it != map.end()) {</div><div class="line">        std::cout &lt;&lt; it-&gt;first.m_name &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    map.erase(1);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    // Use a custom KeyEqual which has an is_transparent member type</div><div class="line">    tsl::ordered_map&lt;employee, int, hash_employee, equal_employee&gt; map2;</div><div class="line">    map2.insert({employee(4, &quot;Johnny Doe&quot;), 2004});</div><div class="line"></div><div class="line">    // 2004</div><div class="line">    std::cout &lt;&lt; map2.at(4) &lt;&lt; std::endl;</div><div class="line">} </div></div><!-- fragment --><h3>License</h3>
<p>The code is licensed under the MIT license, see the [LICENSE file](LICENSE) for details. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
