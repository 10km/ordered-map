<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ordered-map: tsl::ordered_set&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ordered-map
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetsl.html">tsl</a></li><li class="navelem"><a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classtsl_1_1ordered__set-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tsl::ordered_set&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="ordered__set_8h_source.html">ordered_set.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8190bece5d75ab2799ca333f115cc6f4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a8190bece5d75ab2799ca333f115cc6f4">key_type</a> = typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#a52e4f25c7574c93041bdad00cf36ce1c">ht::key_type</a></td></tr>
<tr class="separator:a8190bece5d75ab2799ca333f115cc6f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad290a387d9b1c975cce5d91d29b564d3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#ad290a387d9b1c975cce5d91d29b564d3">value_type</a> = typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#a7fd50353c38360e9d2265b3453b26479">ht::value_type</a></td></tr>
<tr class="separator:ad290a387d9b1c975cce5d91d29b564d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a615521b4ff72b2dfbb95e22a434c9952"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a> = typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#a3d8af7d2c4724a4c1694ef04cc1ba174">ht::size_type</a></td></tr>
<tr class="separator:a615521b4ff72b2dfbb95e22a434c9952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf89af811aefe47f14c87e5114b82f8f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#acf89af811aefe47f14c87e5114b82f8f">difference_type</a> = typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#a0b7cb4d3b0994a104c06d2416ace4b38">ht::difference_type</a></td></tr>
<tr class="separator:acf89af811aefe47f14c87e5114b82f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a917144e739de032c41f7abb02155f62c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a917144e739de032c41f7abb02155f62c">hasher</a> = typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#a8eb174b8de6c61a07f9cbd1b12c9622e">ht::hasher</a></td></tr>
<tr class="separator:a917144e739de032c41f7abb02155f62c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66536243f870308671743cad80bf8434"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a66536243f870308671743cad80bf8434">key_equal</a> = typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#ae3ec06a9c0c0d034cd3f4a980bea8a2c">ht::key_equal</a></td></tr>
<tr class="separator:a66536243f870308671743cad80bf8434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56cb8d6b4da9f6833e4a36066672e145"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a56cb8d6b4da9f6833e4a36066672e145">allocator_type</a> = typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#af9e8a0059565f2741ca3fe0ed71d9c33">ht::allocator_type</a></td></tr>
<tr class="separator:a56cb8d6b4da9f6833e4a36066672e145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af122131d64dc9bb6b0fb924d6439cb87"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#af122131d64dc9bb6b0fb924d6439cb87">reference</a> = typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#ab62bbfff0b1be041224ac796762f394f">ht::reference</a></td></tr>
<tr class="separator:af122131d64dc9bb6b0fb924d6439cb87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8460c26d7e313c243ae8ba378416c437"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a8460c26d7e313c243ae8ba378416c437">const_reference</a> = typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#ab6e7df7fa9475815db35904b80b31d33">ht::const_reference</a></td></tr>
<tr class="separator:a8460c26d7e313c243ae8ba378416c437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f736db91ad71e9853be36e8c0fbd589"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a4f736db91ad71e9853be36e8c0fbd589">pointer</a> = typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#a1f057200fce689b03ddfb035c70657fd">ht::pointer</a></td></tr>
<tr class="separator:a4f736db91ad71e9853be36e8c0fbd589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a174d5887a826ccd980d71d93d0b61c38"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a174d5887a826ccd980d71d93d0b61c38">const_pointer</a> = typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#a4a6408c075332c906a1a3cdc16968178">ht::const_pointer</a></td></tr>
<tr class="separator:a174d5887a826ccd980d71d93d0b61c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ddb85dd322e204aa32a945da8a70aaf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a> = typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#a0d5c36b621bcf1cd2e72efafe38e784b">ht::iterator</a></td></tr>
<tr class="separator:a5ddb85dd322e204aa32a945da8a70aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6451524e20af5e0e0e03a78b9a39dbb2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a> = typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#a15a399d9b811d1deeda821b05042c39c">ht::const_iterator</a></td></tr>
<tr class="separator:a6451524e20af5e0e0e03a78b9a39dbb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1307d1650bbde50b3e3b1761488def"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a6e1307d1650bbde50b3e3b1761488def">reverse_iterator</a> = typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#a90cdb53bdcf81b0be7d4919dda300122">ht::reverse_iterator</a></td></tr>
<tr class="separator:a6e1307d1650bbde50b3e3b1761488def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d51ceb41eb392db19dcba27ac7646f2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a4d51ceb41eb392db19dcba27ac7646f2">const_reverse_iterator</a> = typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#a1a350d04791b1224af0e126370fd0829">ht::const_reverse_iterator</a></td></tr>
<tr class="separator:a4d51ceb41eb392db19dcba27ac7646f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addf17a622dc70f83def6f9f6629dbb46"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#addf17a622dc70f83def6f9f6629dbb46">values_container_type</a> = typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#a14cc7f08290c788be6e51dcb9732e245">ht::values_container_type</a></td></tr>
<tr class="separator:addf17a622dc70f83def6f9f6629dbb46"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa093bde50c74366fe2d2197bd8bfb4ad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#aa093bde50c74366fe2d2197bd8bfb4ad">ordered_set</a> ()</td></tr>
<tr class="separator:aa093bde50c74366fe2d2197bd8bfb4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec61460b894734bea97e6580809ceabf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#aec61460b894734bea97e6580809ceabf">ordered_set</a> (<a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html#ad4e11a5c3f32f3d81b946490a2ef49ba">bucket_count</a>, const Hash &amp;hash=Hash(), const KeyEqual &amp;equal=KeyEqual(), const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="separator:aec61460b894734bea97e6580809ceabf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84c8767e65f08ab21f66eb9f697c0016"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a84c8767e65f08ab21f66eb9f697c0016">ordered_set</a> (<a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html#ad4e11a5c3f32f3d81b946490a2ef49ba">bucket_count</a>, const Allocator &amp;alloc)</td></tr>
<tr class="separator:a84c8767e65f08ab21f66eb9f697c0016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b56fa997ef86cb26a28b2d39fc9bf7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a28b56fa997ef86cb26a28b2d39fc9bf7">ordered_set</a> (<a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html#ad4e11a5c3f32f3d81b946490a2ef49ba">bucket_count</a>, const Hash &amp;hash, const Allocator &amp;alloc)</td></tr>
<tr class="separator:a28b56fa997ef86cb26a28b2d39fc9bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2386828a18647d61a412d1a3a84a2be1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a2386828a18647d61a412d1a3a84a2be1">ordered_set</a> (const Allocator &amp;alloc)</td></tr>
<tr class="separator:a2386828a18647d61a412d1a3a84a2be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7364189bf8c259b4f66fd2dcc44d5baf"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:a7364189bf8c259b4f66fd2dcc44d5baf"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a7364189bf8c259b4f66fd2dcc44d5baf">ordered_set</a> (InputIt first, InputIt last, <a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html#ad4e11a5c3f32f3d81b946490a2ef49ba">bucket_count</a>=<a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#af8c6ab3262ce4655554dbc398759d979">ht::DEFAULT_INIT_BUCKETS_SIZE</a>, const Hash &amp;hash=Hash(), const KeyEqual &amp;equal=KeyEqual(), const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="separator:a7364189bf8c259b4f66fd2dcc44d5baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dfeff8a467a0755415a3a1a63fff72c"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:a2dfeff8a467a0755415a3a1a63fff72c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a2dfeff8a467a0755415a3a1a63fff72c">ordered_set</a> (InputIt first, InputIt last, <a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html#ad4e11a5c3f32f3d81b946490a2ef49ba">bucket_count</a>, const Allocator &amp;alloc)</td></tr>
<tr class="separator:a2dfeff8a467a0755415a3a1a63fff72c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4390cbd5e941224bccc2267ce3605867"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:a4390cbd5e941224bccc2267ce3605867"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a4390cbd5e941224bccc2267ce3605867">ordered_set</a> (InputIt first, InputIt last, <a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html#ad4e11a5c3f32f3d81b946490a2ef49ba">bucket_count</a>, const Hash &amp;hash, const Allocator &amp;alloc)</td></tr>
<tr class="separator:a4390cbd5e941224bccc2267ce3605867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14bddb7f071b5ac1083bf58333a750b6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a14bddb7f071b5ac1083bf58333a750b6">ordered_set</a> (std::initializer_list&lt; <a class="el" href="classtsl_1_1ordered__set.html#ad290a387d9b1c975cce5d91d29b564d3">value_type</a> &gt; init, <a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html#ad4e11a5c3f32f3d81b946490a2ef49ba">bucket_count</a>=<a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#af8c6ab3262ce4655554dbc398759d979">ht::DEFAULT_INIT_BUCKETS_SIZE</a>, const Hash &amp;hash=Hash(), const KeyEqual &amp;equal=KeyEqual(), const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="separator:a14bddb7f071b5ac1083bf58333a750b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a696ce4470aece2e4f78d786087bd0b85"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a696ce4470aece2e4f78d786087bd0b85">ordered_set</a> (std::initializer_list&lt; <a class="el" href="classtsl_1_1ordered__set.html#ad290a387d9b1c975cce5d91d29b564d3">value_type</a> &gt; init, <a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html#ad4e11a5c3f32f3d81b946490a2ef49ba">bucket_count</a>, const Allocator &amp;alloc)</td></tr>
<tr class="separator:a696ce4470aece2e4f78d786087bd0b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c51ec68f00478759f6aff596183d5b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a65c51ec68f00478759f6aff596183d5b">ordered_set</a> (std::initializer_list&lt; <a class="el" href="classtsl_1_1ordered__set.html#ad290a387d9b1c975cce5d91d29b564d3">value_type</a> &gt; init, <a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html#ad4e11a5c3f32f3d81b946490a2ef49ba">bucket_count</a>, const Hash &amp;hash, const Allocator &amp;alloc)</td></tr>
<tr class="separator:a65c51ec68f00478759f6aff596183d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2d061448410872269cbf2617da8db49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#ae2d061448410872269cbf2617da8db49">operator=</a> (std::initializer_list&lt; <a class="el" href="classtsl_1_1ordered__set.html#ad290a387d9b1c975cce5d91d29b564d3">value_type</a> &gt; ilist)</td></tr>
<tr class="separator:ae2d061448410872269cbf2617da8db49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb4c60560b937d7260c85d706d4b21b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a56cb8d6b4da9f6833e4a36066672e145">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#adb4c60560b937d7260c85d706d4b21b8">get_allocator</a> () const</td></tr>
<tr class="separator:adb4c60560b937d7260c85d706d4b21b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d1b55a9a7e209d55f3f8804c8e5038"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a00d1b55a9a7e209d55f3f8804c8e5038">begin</a> () noexcept</td></tr>
<tr class="separator:a00d1b55a9a7e209d55f3f8804c8e5038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b3ec518616264b79a02fff70c1c3f26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a0b3ec518616264b79a02fff70c1c3f26">begin</a> () const noexcept</td></tr>
<tr class="separator:a0b3ec518616264b79a02fff70c1c3f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c4ee174610f28a8a9b39148dbe41ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a32c4ee174610f28a8a9b39148dbe41ab">cbegin</a> () const noexcept</td></tr>
<tr class="separator:a32c4ee174610f28a8a9b39148dbe41ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e27d0dee7772efc44ec2c9456d7d3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a51e27d0dee7772efc44ec2c9456d7d3b">end</a> () noexcept</td></tr>
<tr class="separator:a51e27d0dee7772efc44ec2c9456d7d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc465a04f0581c216bd013d7ae715351"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#acc465a04f0581c216bd013d7ae715351">end</a> () const noexcept</td></tr>
<tr class="separator:acc465a04f0581c216bd013d7ae715351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be448f92258419abcb0dcca7b2d2f24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a1be448f92258419abcb0dcca7b2d2f24">cend</a> () const noexcept</td></tr>
<tr class="separator:a1be448f92258419abcb0dcca7b2d2f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba9174e96e0b66087850d310740c1887"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a6e1307d1650bbde50b3e3b1761488def">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#aba9174e96e0b66087850d310740c1887">rbegin</a> () noexcept</td></tr>
<tr class="separator:aba9174e96e0b66087850d310740c1887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc6c9869db0eea8b9afc48c45359f6bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a4d51ceb41eb392db19dcba27ac7646f2">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#afc6c9869db0eea8b9afc48c45359f6bd">rbegin</a> () const noexcept</td></tr>
<tr class="separator:afc6c9869db0eea8b9afc48c45359f6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f7e3738d25e1a25a10eabb5ed0f804"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a4d51ceb41eb392db19dcba27ac7646f2">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a43f7e3738d25e1a25a10eabb5ed0f804">rcbegin</a> () const noexcept</td></tr>
<tr class="separator:a43f7e3738d25e1a25a10eabb5ed0f804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a596e17766a2a680ce643c82761960c93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a6e1307d1650bbde50b3e3b1761488def">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a596e17766a2a680ce643c82761960c93">rend</a> () noexcept</td></tr>
<tr class="separator:a596e17766a2a680ce643c82761960c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f66a9ed0ed5d1fe757c5faf8445188"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a4d51ceb41eb392db19dcba27ac7646f2">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a84f66a9ed0ed5d1fe757c5faf8445188">rend</a> () const noexcept</td></tr>
<tr class="separator:a84f66a9ed0ed5d1fe757c5faf8445188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ca05754fb6162b9f4d47083722a714"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a4d51ceb41eb392db19dcba27ac7646f2">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a14ca05754fb6162b9f4d47083722a714">rcend</a> () const noexcept</td></tr>
<tr class="separator:a14ca05754fb6162b9f4d47083722a714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7240de6eb338ddfd0357722f2ab8cb62"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a7240de6eb338ddfd0357722f2ab8cb62">empty</a> () const noexcept</td></tr>
<tr class="separator:a7240de6eb338ddfd0357722f2ab8cb62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa340a26b8fd28baeeae5f4e06030faf8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#aa340a26b8fd28baeeae5f4e06030faf8">size</a> () const noexcept</td></tr>
<tr class="separator:aa340a26b8fd28baeeae5f4e06030faf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19825f1c5612c911892afce4d9d7f223"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a19825f1c5612c911892afce4d9d7f223">max_size</a> () const noexcept</td></tr>
<tr class="separator:a19825f1c5612c911892afce4d9d7f223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f48091e3213a558966f529354c602c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#ac6f48091e3213a558966f529354c602c">clear</a> () noexcept</td></tr>
<tr class="separator:ac6f48091e3213a558966f529354c602c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ae6b84e7d515434b44b326eddb9418"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a73ae6b84e7d515434b44b326eddb9418">insert</a> (const <a class="el" href="classtsl_1_1ordered__set.html#ad290a387d9b1c975cce5d91d29b564d3">value_type</a> &amp;value)</td></tr>
<tr class="separator:a73ae6b84e7d515434b44b326eddb9418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79eb045f9d4f88dee53c41b68cb04ea0"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a79eb045f9d4f88dee53c41b68cb04ea0">insert</a> (<a class="el" href="classtsl_1_1ordered__set.html#ad290a387d9b1c975cce5d91d29b564d3">value_type</a> &amp;&amp;value)</td></tr>
<tr class="separator:a79eb045f9d4f88dee53c41b68cb04ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9b8292777d5778c8a56788cbd33721"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a8c9b8292777d5778c8a56788cbd33721">insert</a> (<a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a> hint, const <a class="el" href="classtsl_1_1ordered__set.html#ad290a387d9b1c975cce5d91d29b564d3">value_type</a> &amp;value)</td></tr>
<tr class="separator:a8c9b8292777d5778c8a56788cbd33721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad69a94564252f66399f2924b164cbe71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#ad69a94564252f66399f2924b164cbe71">insert</a> (<a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a> hint, <a class="el" href="classtsl_1_1ordered__set.html#ad290a387d9b1c975cce5d91d29b564d3">value_type</a> &amp;&amp;value)</td></tr>
<tr class="separator:ad69a94564252f66399f2924b164cbe71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e21e3ac35b265cf2ff2eebb6545b66"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:a80e21e3ac35b265cf2ff2eebb6545b66"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a80e21e3ac35b265cf2ff2eebb6545b66">insert</a> (InputIt first, InputIt last)</td></tr>
<tr class="separator:a80e21e3ac35b265cf2ff2eebb6545b66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c11c76775dc7cec5ce7feec2b099c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a85c11c76775dc7cec5ce7feec2b099c6">insert</a> (std::initializer_list&lt; <a class="el" href="classtsl_1_1ordered__set.html#ad290a387d9b1c975cce5d91d29b564d3">value_type</a> &gt; ilist)</td></tr>
<tr class="separator:a85c11c76775dc7cec5ce7feec2b099c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f7b647a5556bcc2f7c70321934c5fd8"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a6f7b647a5556bcc2f7c70321934c5fd8"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a6f7b647a5556bcc2f7c70321934c5fd8">emplace</a> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:a6f7b647a5556bcc2f7c70321934c5fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8032d960097ce91ea63df6b1a6a7189c"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a8032d960097ce91ea63df6b1a6a7189c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a8032d960097ce91ea63df6b1a6a7189c">emplace_hint</a> (<a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a> hint, Args &amp;&amp;... args)</td></tr>
<tr class="separator:a8032d960097ce91ea63df6b1a6a7189c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de3674ef76ad14c5d818c972c8fbca4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a2de3674ef76ad14c5d818c972c8fbca4">erase</a> (<a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a> pos)</td></tr>
<tr class="separator:a2de3674ef76ad14c5d818c972c8fbca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1a43c0ee7ba0748185883de0e879d01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#ae1a43c0ee7ba0748185883de0e879d01">erase</a> (<a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a> pos)</td></tr>
<tr class="separator:ae1a43c0ee7ba0748185883de0e879d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b1e1f6c4a10b446b27fa74bfd4d283"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a64b1e1f6c4a10b446b27fa74bfd4d283">erase</a> (<a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a> first, <a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a> last)</td></tr>
<tr class="separator:a64b1e1f6c4a10b446b27fa74bfd4d283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac10b6934e825cb57c73f0dac6f7c7c73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#ac10b6934e825cb57c73f0dac6f7c7c73">erase</a> (const <a class="el" href="classtsl_1_1ordered__set.html#a8190bece5d75ab2799ca333f115cc6f4">key_type</a> &amp;key)</td></tr>
<tr class="separator:ac10b6934e825cb57c73f0dac6f7c7c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc4a8693220e7513af092a6e4d54e27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a7cc4a8693220e7513af092a6e4d54e27">erase</a> (const <a class="el" href="classtsl_1_1ordered__set.html#a8190bece5d75ab2799ca333f115cc6f4">key_type</a> &amp;key, std::size_t precalculated_hash)</td></tr>
<tr class="separator:a7cc4a8693220e7513af092a6e4d54e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada9488b9047e0a5cad040cf3b74f83ec"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ada9488b9047e0a5cad040cf3b74f83ec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#ada9488b9047e0a5cad040cf3b74f83ec">erase</a> (const K &amp;key)</td></tr>
<tr class="separator:ada9488b9047e0a5cad040cf3b74f83ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a0cd3c395b39468f09c3570bbe47f17"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a2a0cd3c395b39468f09c3570bbe47f17"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a2a0cd3c395b39468f09c3570bbe47f17">erase</a> (const K &amp;key, std::size_t precalculated_hash)</td></tr>
<tr class="separator:a2a0cd3c395b39468f09c3570bbe47f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b58ba67f8879a171041611e3cf0cb27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a7b58ba67f8879a171041611e3cf0cb27">swap</a> (<a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> &amp;other)</td></tr>
<tr class="separator:a7b58ba67f8879a171041611e3cf0cb27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae5383c6edca82403dc8ab3f6558cd74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#aae5383c6edca82403dc8ab3f6558cd74">count</a> (const Key &amp;key) const</td></tr>
<tr class="separator:aae5383c6edca82403dc8ab3f6558cd74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43cd6332c190546b81f321de95a24966"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a43cd6332c190546b81f321de95a24966">count</a> (const Key &amp;key, std::size_t precalculated_hash) const</td></tr>
<tr class="separator:a43cd6332c190546b81f321de95a24966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee24260b067f1ebc68059b8c230b07b"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a3ee24260b067f1ebc68059b8c230b07b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a3ee24260b067f1ebc68059b8c230b07b">count</a> (const K &amp;key) const</td></tr>
<tr class="separator:a3ee24260b067f1ebc68059b8c230b07b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf64e59ed51841f79b24755c766a6b1"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:aacf64e59ed51841f79b24755c766a6b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#aacf64e59ed51841f79b24755c766a6b1">count</a> (const K &amp;key, std::size_t precalculated_hash) const</td></tr>
<tr class="separator:aacf64e59ed51841f79b24755c766a6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab0ffd41467c4d1034c039926fea912"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#adab0ffd41467c4d1034c039926fea912">find</a> (const Key &amp;key)</td></tr>
<tr class="separator:adab0ffd41467c4d1034c039926fea912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb93be16ccaee97295dcb3d2286f17c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#abb93be16ccaee97295dcb3d2286f17c8">find</a> (const Key &amp;key, std::size_t precalculated_hash)</td></tr>
<tr class="separator:abb93be16ccaee97295dcb3d2286f17c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c00bb384d0586448c22d79376ac4051"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a8c00bb384d0586448c22d79376ac4051">find</a> (const Key &amp;key) const</td></tr>
<tr class="separator:a8c00bb384d0586448c22d79376ac4051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63d187abe1c1dc1e401342bcdede2cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#af63d187abe1c1dc1e401342bcdede2cd">find</a> (const Key &amp;key, std::size_t precalculated_hash) const</td></tr>
<tr class="separator:af63d187abe1c1dc1e401342bcdede2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c3444cfb6a06cb168db22578d81dc9"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a02c3444cfb6a06cb168db22578d81dc9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a02c3444cfb6a06cb168db22578d81dc9">find</a> (const K &amp;key)</td></tr>
<tr class="separator:a02c3444cfb6a06cb168db22578d81dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accc6083c9c1192016cd0071405a507f0"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:accc6083c9c1192016cd0071405a507f0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#accc6083c9c1192016cd0071405a507f0">find</a> (const K &amp;key, std::size_t precalculated_hash)</td></tr>
<tr class="separator:accc6083c9c1192016cd0071405a507f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea337e7a2128b545480be33d89dc5cf"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a8ea337e7a2128b545480be33d89dc5cf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a8ea337e7a2128b545480be33d89dc5cf">find</a> (const K &amp;key) const</td></tr>
<tr class="separator:a8ea337e7a2128b545480be33d89dc5cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c13b1e6569ddacba07d97093b5c423"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ac5c13b1e6569ddacba07d97093b5c423"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#ac5c13b1e6569ddacba07d97093b5c423">find</a> (const K &amp;key, std::size_t precalculated_hash) const</td></tr>
<tr class="separator:ac5c13b1e6569ddacba07d97093b5c423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab859f45160f79d15c3fbd27f495e4e2d"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a>, <a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#ab859f45160f79d15c3fbd27f495e4e2d">equal_range</a> (const Key &amp;key)</td></tr>
<tr class="separator:ab859f45160f79d15c3fbd27f495e4e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf13a82541945e56a06889dbe93a23c4"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a>, <a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#abf13a82541945e56a06889dbe93a23c4">equal_range</a> (const Key &amp;key, std::size_t precalculated_hash)</td></tr>
<tr class="separator:abf13a82541945e56a06889dbe93a23c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3197cd4acf03f94be9d0dc5f7291c5c5"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a>, <a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a3197cd4acf03f94be9d0dc5f7291c5c5">equal_range</a> (const Key &amp;key) const</td></tr>
<tr class="separator:a3197cd4acf03f94be9d0dc5f7291c5c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a891e817b65bf3688bae8dfa4fe1b4ef6"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a>, <a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a891e817b65bf3688bae8dfa4fe1b4ef6">equal_range</a> (const Key &amp;key, std::size_t precalculated_hash) const</td></tr>
<tr class="separator:a891e817b65bf3688bae8dfa4fe1b4ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ad7016e42d448e79be9309a4914a06"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a22ad7016e42d448e79be9309a4914a06"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a>, <a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a22ad7016e42d448e79be9309a4914a06">equal_range</a> (const K &amp;key)</td></tr>
<tr class="separator:a22ad7016e42d448e79be9309a4914a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb675ea5fcf23116a4475e02cf6c0824"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:afb675ea5fcf23116a4475e02cf6c0824"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a>, <a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#afb675ea5fcf23116a4475e02cf6c0824">equal_range</a> (const K &amp;key, std::size_t precalculated_hash)</td></tr>
<tr class="separator:afb675ea5fcf23116a4475e02cf6c0824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af47b7f7f6d7ed8bf442983d8b37d8fff"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:af47b7f7f6d7ed8bf442983d8b37d8fff"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a>, <a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#af47b7f7f6d7ed8bf442983d8b37d8fff">equal_range</a> (const K &amp;key) const</td></tr>
<tr class="separator:af47b7f7f6d7ed8bf442983d8b37d8fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2edb279590c57fc5390f36c7b4a0f83"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ac2edb279590c57fc5390f36c7b4a0f83"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a>, <a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#ac2edb279590c57fc5390f36c7b4a0f83">equal_range</a> (const K &amp;key, std::size_t precalculated_hash) const</td></tr>
<tr class="separator:ac2edb279590c57fc5390f36c7b4a0f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e11a5c3f32f3d81b946490a2ef49ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#ad4e11a5c3f32f3d81b946490a2ef49ba">bucket_count</a> () const</td></tr>
<tr class="separator:ad4e11a5c3f32f3d81b946490a2ef49ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc20926ecc35fd9696351f64f6fad8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#aecc20926ecc35fd9696351f64f6fad8e">max_bucket_count</a> () const</td></tr>
<tr class="separator:aecc20926ecc35fd9696351f64f6fad8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a255ffc4d07c742995ddaa6e2a94dd476"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a255ffc4d07c742995ddaa6e2a94dd476">load_factor</a> () const</td></tr>
<tr class="separator:a255ffc4d07c742995ddaa6e2a94dd476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62c303e8b56f1de355ba7bb2f15d45da"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a62c303e8b56f1de355ba7bb2f15d45da">max_load_factor</a> () const</td></tr>
<tr class="separator:a62c303e8b56f1de355ba7bb2f15d45da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6335e8c9e7de6a07315d767a2c4f7ddc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a6335e8c9e7de6a07315d767a2c4f7ddc">max_load_factor</a> (float ml)</td></tr>
<tr class="separator:a6335e8c9e7de6a07315d767a2c4f7ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac58d260c2cf387ea01f4ac56dd389c1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#ac58d260c2cf387ea01f4ac56dd389c1c">rehash</a> (<a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html#aae5383c6edca82403dc8ab3f6558cd74">count</a>)</td></tr>
<tr class="separator:ac58d260c2cf387ea01f4ac56dd389c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a9df6a5bff4ad7fdc1eb0afac5ffa7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#ab0a9df6a5bff4ad7fdc1eb0afac5ffa7">reserve</a> (<a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html#aae5383c6edca82403dc8ab3f6558cd74">count</a>)</td></tr>
<tr class="separator:ab0a9df6a5bff4ad7fdc1eb0afac5ffa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0177d37fd16de14da45fb8b106980a13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a917144e739de032c41f7abb02155f62c">hasher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a0177d37fd16de14da45fb8b106980a13">hash_function</a> () const</td></tr>
<tr class="separator:a0177d37fd16de14da45fb8b106980a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec9b3316e018b6bb4a1b11f474f37905"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a66536243f870308671743cad80bf8434">key_equal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#aec9b3316e018b6bb4a1b11f474f37905">key_eq</a> () const</td></tr>
<tr class="separator:aec9b3316e018b6bb4a1b11f474f37905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ec112b08bfc835d08770af4e90df1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a39ec112b08bfc835d08770af4e90df1f">mutable_iterator</a> (<a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a> pos)</td></tr>
<tr class="separator:a39ec112b08bfc835d08770af4e90df1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc214c68435ebb5e82952c164ad31951"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#abc214c68435ebb5e82952c164ad31951">nth</a> (<a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a> index)</td></tr>
<tr class="separator:abc214c68435ebb5e82952c164ad31951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8140877c268625e5a80111138d03614b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a8140877c268625e5a80111138d03614b">nth</a> (<a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a> index) const</td></tr>
<tr class="separator:a8140877c268625e5a80111138d03614b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad88dbc0d34ee749eb88c8d9db5e1c4fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a8460c26d7e313c243ae8ba378416c437">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#ad88dbc0d34ee749eb88c8d9db5e1c4fb">front</a> () const</td></tr>
<tr class="separator:ad88dbc0d34ee749eb88c8d9db5e1c4fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3812f725617a996be71b6827d458a82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a8460c26d7e313c243ae8ba378416c437">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#ac3812f725617a996be71b6827d458a82">back</a> () const</td></tr>
<tr class="separator:ac3812f725617a996be71b6827d458a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b4dbb9e10448268854db54a838f0933"><td class="memTemplParams" colspan="2">template&lt;class U  = values_container_type, typename std::enable_if&lt; tsl::detail_ordered_hash::is_vector&lt; U &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a0b4dbb9e10448268854db54a838f0933"><td class="memTemplItemLeft" align="right" valign="top">const values_container_type::value_type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a0b4dbb9e10448268854db54a838f0933">data</a> () const noexcept</td></tr>
<tr class="separator:a0b4dbb9e10448268854db54a838f0933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b0ac6b63103e557507a98b638026bd7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtsl_1_1ordered__set.html#addf17a622dc70f83def6f9f6629dbb46">values_container_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a6b0ac6b63103e557507a98b638026bd7">values_container</a> () const noexcept</td></tr>
<tr class="separator:a6b0ac6b63103e557507a98b638026bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da24e56ecd16553c73bc534ea7b5ec3"><td class="memTemplParams" colspan="2">template&lt;class U  = values_container_type, typename std::enable_if&lt; tsl::detail_ordered_hash::is_vector&lt; U &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a6da24e56ecd16553c73bc534ea7b5ec3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a6da24e56ecd16553c73bc534ea7b5ec3">capacity</a> () const noexcept</td></tr>
<tr class="separator:a6da24e56ecd16553c73bc534ea7b5ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a0115911c64f13b87e015fb76304776"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a3a0115911c64f13b87e015fb76304776">shrink_to_fit</a> ()</td></tr>
<tr class="separator:a3a0115911c64f13b87e015fb76304776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b5bf5ee74849fbfe2af8ac0f63ba95"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a70b5bf5ee74849fbfe2af8ac0f63ba95">insert_at_position</a> (<a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a> pos, const <a class="el" href="classtsl_1_1ordered__set.html#ad290a387d9b1c975cce5d91d29b564d3">value_type</a> &amp;value)</td></tr>
<tr class="separator:a70b5bf5ee74849fbfe2af8ac0f63ba95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af5289dd180a6b70eb8f8fd3539c722"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a0af5289dd180a6b70eb8f8fd3539c722">insert_at_position</a> (<a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a> pos, <a class="el" href="classtsl_1_1ordered__set.html#ad290a387d9b1c975cce5d91d29b564d3">value_type</a> &amp;&amp;value)</td></tr>
<tr class="separator:a0af5289dd180a6b70eb8f8fd3539c722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01cd751ac9b1b77cfff692aaa420b679"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a01cd751ac9b1b77cfff692aaa420b679"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a01cd751ac9b1b77cfff692aaa420b679">emplace_at_position</a> (<a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a> pos, Args &amp;&amp;... args)</td></tr>
<tr class="separator:a01cd751ac9b1b77cfff692aaa420b679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3fbdf9c812e792bbff41e69bdd68eb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#ad3fbdf9c812e792bbff41e69bdd68eb6">pop_back</a> ()</td></tr>
<tr class="separator:ad3fbdf9c812e792bbff41e69bdd68eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af95469fae633c17d50747abe2593edfe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#af95469fae633c17d50747abe2593edfe">unordered_erase</a> (<a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a> pos)</td></tr>
<tr class="separator:af95469fae633c17d50747abe2593edfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedffc8935ca7d9c3e9eccf7b8761ac62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#aedffc8935ca7d9c3e9eccf7b8761ac62">unordered_erase</a> (<a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a> pos)</td></tr>
<tr class="separator:aedffc8935ca7d9c3e9eccf7b8761ac62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a2ff70375bf1b75fbe7957873ccd784"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a7a2ff70375bf1b75fbe7957873ccd784">unordered_erase</a> (const <a class="el" href="classtsl_1_1ordered__set.html#a8190bece5d75ab2799ca333f115cc6f4">key_type</a> &amp;key)</td></tr>
<tr class="separator:a7a2ff70375bf1b75fbe7957873ccd784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7c74aa9b459b9febeb446fcb5a7e59f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#aa7c74aa9b459b9febeb446fcb5a7e59f">unordered_erase</a> (const <a class="el" href="classtsl_1_1ordered__set.html#a8190bece5d75ab2799ca333f115cc6f4">key_type</a> &amp;key, std::size_t precalculated_hash)</td></tr>
<tr class="separator:aa7c74aa9b459b9febeb446fcb5a7e59f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebda9edd78a5103e1a5105defb634af6"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:aebda9edd78a5103e1a5105defb634af6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#aebda9edd78a5103e1a5105defb634af6">unordered_erase</a> (const K &amp;key)</td></tr>
<tr class="separator:aebda9edd78a5103e1a5105defb634af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2aa883c427fd9b1f381e6c3cd1f09fb"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:af2aa883c427fd9b1f381e6c3cd1f09fb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#af2aa883c427fd9b1f381e6c3cd1f09fb">unordered_erase</a> (const K &amp;key, std::size_t precalculated_hash)</td></tr>
<tr class="separator:af2aa883c427fd9b1f381e6c3cd1f09fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aa58b43c0c001cea18c9b7d7714b9d85c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#aa58b43c0c001cea18c9b7d7714b9d85c">operator==</a> (const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> &amp;lhs, const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> &amp;rhs)</td></tr>
<tr class="separator:aa58b43c0c001cea18c9b7d7714b9d85c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafca13b71af5e35082b3e22c01680844"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#aafca13b71af5e35082b3e22c01680844">operator!=</a> (const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> &amp;lhs, const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> &amp;rhs)</td></tr>
<tr class="separator:aafca13b71af5e35082b3e22c01680844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad685a66cbb7c59a0923ca7d57a734c27"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#ad685a66cbb7c59a0923ca7d57a734c27">operator&lt;</a> (const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> &amp;lhs, const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> &amp;rhs)</td></tr>
<tr class="separator:ad685a66cbb7c59a0923ca7d57a734c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a506164f732a96dfefef194dd47c5459d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a506164f732a96dfefef194dd47c5459d">operator&lt;=</a> (const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> &amp;lhs, const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> &amp;rhs)</td></tr>
<tr class="separator:a506164f732a96dfefef194dd47c5459d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59796ffdc4400bdcb82073c952cdf451"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a59796ffdc4400bdcb82073c952cdf451">operator&gt;</a> (const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> &amp;lhs, const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> &amp;rhs)</td></tr>
<tr class="separator:a59796ffdc4400bdcb82073c952cdf451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a17aeb7a1827b4f3cc26552ddb9db0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a94a17aeb7a1827b4f3cc26552ddb9db0">operator&gt;=</a> (const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> &amp;lhs, const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> &amp;rhs)</td></tr>
<tr class="separator:a94a17aeb7a1827b4f3cc26552ddb9db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb2c2dd5207da0a8b606fc11fa6dba8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a5fb2c2dd5207da0a8b606fc11fa6dba8">swap</a> (<a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> &amp;lhs, <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> &amp;rhs)</td></tr>
<tr class="separator:a5fb2c2dd5207da0a8b606fc11fa6dba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, class ValueTypeContainer = std::deque&lt;Key, Allocator&gt;&gt;<br />
class tsl::ordered_set&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;</h3>

<p>Implementation of an hash set using open adressing with robin hood with backshift delete to resolve collisions.</p>
<p>The particularity of this hash set is that it remembers the order in which the elements were added and provide a way to access the structure which stores these values through the '<a class="el" href="classtsl_1_1ordered__set.html#a6b0ac6b63103e557507a98b638026bd7">values_container()</a>' method. The used container is defined by ValueTypeContainer, by default a std::deque is used (grows faster) but a std::vector may be used. In this case the set provides a '<a class="el" href="classtsl_1_1ordered__set.html#a0b4dbb9e10448268854db54a838f0933">data()</a>' method which give a direct access to the memory used to store the values (which can be usefull to communicate with C API's).</p>
<p>The Key must be copy constructible and/or move constructible. To use <code>unordered_erase</code> it also must be swappable.</p>
<p>The behaviour of the hash set is undefinded if the destructor of Key throws an exception.</p>
<p>Iterators invalidation:</p><ul>
<li>clear, operator=, reserve, rehash: always invalidate the iterators (also invalidate <a class="el" href="classtsl_1_1ordered__set.html#a51e27d0dee7772efc44ec2c9456d7d3b">end()</a>).</li>
<li>insert, emplace, emplace_hint, operator[]: when a std::vector is used as ValueTypeContainer and if <a class="el" href="classtsl_1_1ordered__set.html#aa340a26b8fd28baeeae5f4e06030faf8">size()</a> &lt; <a class="el" href="classtsl_1_1ordered__set.html#a6da24e56ecd16553c73bc534ea7b5ec3">capacity()</a>, only <a class="el" href="classtsl_1_1ordered__set.html#a51e27d0dee7772efc44ec2c9456d7d3b">end()</a>. Otherwise all the iterators are invalidated if an insert occurs.</li>
<li>erase, unordered_erase: when a std::vector is used as ValueTypeContainer invalidate the iterator of the erased element and all the ones after the erased element (including <a class="el" href="classtsl_1_1ordered__set.html#a51e27d0dee7772efc44ec2c9456d7d3b">end()</a>). Otherwise all the iterators are invalidated if an erase occurs. </li>
</ul>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a56cb8d6b4da9f6833e4a36066672e145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56cb8d6b4da9f6833e4a36066672e145">&#9670;&nbsp;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::<a class="el" href="classtsl_1_1ordered__set.html#a56cb8d6b4da9f6833e4a36066672e145">allocator_type</a> =  typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#af9e8a0059565f2741ca3fe0ed71d9c33">ht::allocator_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6451524e20af5e0e0e03a78b9a39dbb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6451524e20af5e0e0e03a78b9a39dbb2">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::<a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a> =  typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#a15a399d9b811d1deeda821b05042c39c">ht::const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a174d5887a826ccd980d71d93d0b61c38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a174d5887a826ccd980d71d93d0b61c38">&#9670;&nbsp;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::<a class="el" href="classtsl_1_1ordered__set.html#a174d5887a826ccd980d71d93d0b61c38">const_pointer</a> =  typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#a4a6408c075332c906a1a3cdc16968178">ht::const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8460c26d7e313c243ae8ba378416c437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8460c26d7e313c243ae8ba378416c437">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::<a class="el" href="classtsl_1_1ordered__set.html#a8460c26d7e313c243ae8ba378416c437">const_reference</a> =  typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#ab6e7df7fa9475815db35904b80b31d33">ht::const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4d51ceb41eb392db19dcba27ac7646f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d51ceb41eb392db19dcba27ac7646f2">&#9670;&nbsp;</a></span>const_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::<a class="el" href="classtsl_1_1ordered__set.html#a4d51ceb41eb392db19dcba27ac7646f2">const_reverse_iterator</a> =  typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#a1a350d04791b1224af0e126370fd0829">ht::const_reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acf89af811aefe47f14c87e5114b82f8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf89af811aefe47f14c87e5114b82f8f">&#9670;&nbsp;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::<a class="el" href="classtsl_1_1ordered__set.html#acf89af811aefe47f14c87e5114b82f8f">difference_type</a> =  typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#a0b7cb4d3b0994a104c06d2416ace4b38">ht::difference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a917144e739de032c41f7abb02155f62c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a917144e739de032c41f7abb02155f62c">&#9670;&nbsp;</a></span>hasher</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::<a class="el" href="classtsl_1_1ordered__set.html#a917144e739de032c41f7abb02155f62c">hasher</a> =  typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#a8eb174b8de6c61a07f9cbd1b12c9622e">ht::hasher</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5ddb85dd322e204aa32a945da8a70aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ddb85dd322e204aa32a945da8a70aaf">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::<a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a> =  typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#a0d5c36b621bcf1cd2e72efafe38e784b">ht::iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a66536243f870308671743cad80bf8434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66536243f870308671743cad80bf8434">&#9670;&nbsp;</a></span>key_equal</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::<a class="el" href="classtsl_1_1ordered__set.html#a66536243f870308671743cad80bf8434">key_equal</a> =  typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#ae3ec06a9c0c0d034cd3f4a980bea8a2c">ht::key_equal</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8190bece5d75ab2799ca333f115cc6f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8190bece5d75ab2799ca333f115cc6f4">&#9670;&nbsp;</a></span>key_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::<a class="el" href="classtsl_1_1ordered__set.html#a8190bece5d75ab2799ca333f115cc6f4">key_type</a> =  typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#a52e4f25c7574c93041bdad00cf36ce1c">ht::key_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4f736db91ad71e9853be36e8c0fbd589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f736db91ad71e9853be36e8c0fbd589">&#9670;&nbsp;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::<a class="el" href="classtsl_1_1ordered__set.html#a4f736db91ad71e9853be36e8c0fbd589">pointer</a> =  typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#a1f057200fce689b03ddfb035c70657fd">ht::pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af122131d64dc9bb6b0fb924d6439cb87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af122131d64dc9bb6b0fb924d6439cb87">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::<a class="el" href="classtsl_1_1ordered__set.html#af122131d64dc9bb6b0fb924d6439cb87">reference</a> =  typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#ab62bbfff0b1be041224ac796762f394f">ht::reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6e1307d1650bbde50b3e3b1761488def"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e1307d1650bbde50b3e3b1761488def">&#9670;&nbsp;</a></span>reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::<a class="el" href="classtsl_1_1ordered__set.html#a6e1307d1650bbde50b3e3b1761488def">reverse_iterator</a> =  typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#a90cdb53bdcf81b0be7d4919dda300122">ht::reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a615521b4ff72b2dfbb95e22a434c9952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a615521b4ff72b2dfbb95e22a434c9952">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::<a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a> =  typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#a3d8af7d2c4724a4c1694ef04cc1ba174">ht::size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad290a387d9b1c975cce5d91d29b564d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad290a387d9b1c975cce5d91d29b564d3">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::<a class="el" href="classtsl_1_1ordered__set.html#ad290a387d9b1c975cce5d91d29b564d3">value_type</a> =  typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#a7fd50353c38360e9d2265b3453b26479">ht::value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="addf17a622dc70f83def6f9f6629dbb46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addf17a622dc70f83def6f9f6629dbb46">&#9670;&nbsp;</a></span>values_container_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::<a class="el" href="classtsl_1_1ordered__set.html#addf17a622dc70f83def6f9f6629dbb46">values_container_type</a> =  typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#a14cc7f08290c788be6e51dcb9732e245">ht::values_container_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa093bde50c74366fe2d2197bd8bfb4ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa093bde50c74366fe2d2197bd8bfb4ad">&#9670;&nbsp;</a></span>ordered_set() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::<a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aec61460b894734bea97e6580809ceabf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec61460b894734bea97e6580809ceabf">&#9670;&nbsp;</a></span>ordered_set() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::<a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;&#160;</td>
          <td class="paramname"><em>hash</em> = <code>Hash()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyEqual &amp;&#160;</td>
          <td class="paramname"><em>equal</em> = <code>KeyEqual()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a84c8767e65f08ab21f66eb9f697c0016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84c8767e65f08ab21f66eb9f697c0016">&#9670;&nbsp;</a></span>ordered_set() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::<a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a28b56fa997ef86cb26a28b2d39fc9bf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28b56fa997ef86cb26a28b2d39fc9bf7">&#9670;&nbsp;</a></span>ordered_set() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::<a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2386828a18647d61a412d1a3a84a2be1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2386828a18647d61a412d1a3a84a2be1">&#9670;&nbsp;</a></span>ordered_set() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::<a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> </td>
          <td>(</td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7364189bf8c259b4f66fd2dcc44d5baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7364189bf8c259b4f66fd2dcc44d5baf">&#9670;&nbsp;</a></span>ordered_set() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::<a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em> = <code><a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#af8c6ab3262ce4655554dbc398759d979">ht::DEFAULT_INIT_BUCKETS_SIZE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;&#160;</td>
          <td class="paramname"><em>hash</em> = <code>Hash()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyEqual &amp;&#160;</td>
          <td class="paramname"><em>equal</em> = <code>KeyEqual()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2dfeff8a467a0755415a3a1a63fff72c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dfeff8a467a0755415a3a1a63fff72c">&#9670;&nbsp;</a></span>ordered_set() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::<a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4390cbd5e941224bccc2267ce3605867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4390cbd5e941224bccc2267ce3605867">&#9670;&nbsp;</a></span>ordered_set() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::<a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a14bddb7f071b5ac1083bf58333a750b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14bddb7f071b5ac1083bf58333a750b6">&#9670;&nbsp;</a></span>ordered_set() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::<a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classtsl_1_1ordered__set.html#ad290a387d9b1c975cce5d91d29b564d3">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em> = <code><a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#af8c6ab3262ce4655554dbc398759d979">ht::DEFAULT_INIT_BUCKETS_SIZE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;&#160;</td>
          <td class="paramname"><em>hash</em> = <code>Hash()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyEqual &amp;&#160;</td>
          <td class="paramname"><em>equal</em> = <code>KeyEqual()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a696ce4470aece2e4f78d786087bd0b85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a696ce4470aece2e4f78d786087bd0b85">&#9670;&nbsp;</a></span>ordered_set() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::<a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classtsl_1_1ordered__set.html#ad290a387d9b1c975cce5d91d29b564d3">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a65c51ec68f00478759f6aff596183d5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65c51ec68f00478759f6aff596183d5b">&#9670;&nbsp;</a></span>ordered_set() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::<a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classtsl_1_1ordered__set.html#ad290a387d9b1c975cce5d91d29b564d3">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac3812f725617a996be71b6827d458a82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3812f725617a996be71b6827d458a82">&#9670;&nbsp;</a></span>back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a8460c26d7e313c243ae8ba378416c437">const_reference</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return const_reference to the last element. Requires the container to not be empty. </p>

</div>
</div>
<a id="a00d1b55a9a7e209d55f3f8804c8e5038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00d1b55a9a7e209d55f3f8804c8e5038">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b3ec518616264b79a02fff70c1c3f26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b3ec518616264b79a02fff70c1c3f26">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad4e11a5c3f32f3d81b946490a2ef49ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4e11a5c3f32f3d81b946490a2ef49ba">&#9670;&nbsp;</a></span>bucket_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::bucket_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6da24e56ecd16553c73bc534ea7b5ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6da24e56ecd16553c73bc534ea7b5ec3">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<div class="memtemplate">
template&lt;class U  = values_container_type, typename std::enable_if&lt; tsl::detail_ordered_hash::is_vector&lt; U &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a32c4ee174610f28a8a9b39148dbe41ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32c4ee174610f28a8a9b39148dbe41ab">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1be448f92258419abcb0dcca7b2d2f24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1be448f92258419abcb0dcca7b2d2f24">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac6f48091e3213a558966f529354c602c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6f48091e3213a558966f529354c602c">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aae5383c6edca82403dc8ab3f6558cd74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae5383c6edca82403dc8ab3f6558cd74">&#9670;&nbsp;</a></span>count() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a43cd6332c190546b81f321de95a24966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43cd6332c190546b81f321de95a24966">&#9670;&nbsp;</a></span>count() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1ordered__set.html#a0177d37fd16de14da45fb8b106980a13">hash_function()</a>(key). Usefull to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a3ee24260b067f1ebc68059b8c230b07b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ee24260b067f1ebc68059b8c230b07b">&#9670;&nbsp;</a></span>count() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="aacf64e59ed51841f79b24755c766a6b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacf64e59ed51841f79b24755c766a6b1">&#9670;&nbsp;</a></span>count() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key.</p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1ordered__set.html#a0177d37fd16de14da45fb8b106980a13">hash_function()</a>(key). Usefull to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a0b4dbb9e10448268854db54a838f0933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b4dbb9e10448268854db54a838f0933">&#9670;&nbsp;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<div class="memtemplate">
template&lt;class U  = values_container_type, typename std::enable_if&lt; tsl::detail_ordered_hash::is_vector&lt; U &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const values_container_type::value_type* <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Only available if ValueTypeContainer is a std::vector. Same as calling '<a class="el" href="classtsl_1_1ordered__set.html#a6b0ac6b63103e557507a98b638026bd7">values_container()</a>.<a class="el" href="classtsl_1_1ordered__set.html#a0b4dbb9e10448268854db54a838f0933">data()</a>'. </p>

</div>
</div>
<a id="a6f7b647a5556bcc2f7c70321934c5fd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f7b647a5556bcc2f7c70321934c5fd8">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a>, bool&gt; <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Due to the way elements are stored, emplace will need to move or copy the key-value once. The method is equivalent to insert(value_type(std::forward&lt;Args&gt;(args)...));</p>
<p>Mainly here for compatibility with the std::unordered_map interface. </p>

</div>
</div>
<a id="a01cd751ac9b1b77cfff692aaa420b679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01cd751ac9b1b77cfff692aaa420b679">&#9670;&nbsp;</a></span>emplace_at_position()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a>, bool&gt; <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::emplace_at_position </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Insert the value before pos shifting all the elements on the right of pos (including pos) one position to the right.</p>
<p>Amortized linear time-complexity in the distance between pos and <a class="el" href="classtsl_1_1ordered__set.html#a51e27d0dee7772efc44ec2c9456d7d3b">end()</a>.</p>
<p>Same as insert_at_position(pos, value_type(std::forward&lt;Args&gt;(args)...), mainly here for coherence. </p>

</div>
</div>
<a id="a8032d960097ce91ea63df6b1a6a7189c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8032d960097ce91ea63df6b1a6a7189c">&#9670;&nbsp;</a></span>emplace_hint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::emplace_hint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Due to the way elements are stored, emplace_hint will need to move or copy the key-value once. The method is equivalent to insert(hint, value_type(std::forward&lt;Args&gt;(args)...));</p>
<p>Mainly here for compatibility with the std::unordered_map interface. </p>

</div>
</div>
<a id="a7240de6eb338ddfd0357722f2ab8cb62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7240de6eb338ddfd0357722f2ab8cb62">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a51e27d0dee7772efc44ec2c9456d7d3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51e27d0dee7772efc44ec2c9456d7d3b">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acc465a04f0581c216bd013d7ae715351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc465a04f0581c216bd013d7ae715351">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab859f45160f79d15c3fbd27f495e4e2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab859f45160f79d15c3fbd27f495e4e2d">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a>, <a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a>&gt; <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abf13a82541945e56a06889dbe93a23c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf13a82541945e56a06889dbe93a23c4">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a>, <a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a>&gt; <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1ordered__set.html#a0177d37fd16de14da45fb8b106980a13">hash_function()</a>(key). Usefull to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a3197cd4acf03f94be9d0dc5f7291c5c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3197cd4acf03f94be9d0dc5f7291c5c5">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a>, <a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a>&gt; <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a891e817b65bf3688bae8dfa4fe1b4ef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a891e817b65bf3688bae8dfa4fe1b4ef6">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a>, <a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a>&gt; <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1ordered__set.html#a0177d37fd16de14da45fb8b106980a13">hash_function()</a>(key). Usefull to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a22ad7016e42d448e79be9309a4914a06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22ad7016e42d448e79be9309a4914a06">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a>, <a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a>&gt; <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="afb675ea5fcf23116a4475e02cf6c0824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb675ea5fcf23116a4475e02cf6c0824">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a>, <a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a>&gt; <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key.</p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1ordered__set.html#a0177d37fd16de14da45fb8b106980a13">hash_function()</a>(key). Usefull to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="af47b7f7f6d7ed8bf442983d8b37d8fff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af47b7f7f6d7ed8bf442983d8b37d8fff">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a>, <a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a>&gt; <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="ac2edb279590c57fc5390f36c7b4a0f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2edb279590c57fc5390f36c7b4a0f83">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a>, <a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a>&gt; <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key.</p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1ordered__set.html#a0177d37fd16de14da45fb8b106980a13">hash_function()</a>(key). Usefull to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a2de3674ef76ad14c5d818c972c8fbca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2de3674ef76ad14c5d818c972c8fbca4">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When erasing an element, the insert order will be preserved and no holes will be present in the container returned by '<a class="el" href="classtsl_1_1ordered__set.html#a6b0ac6b63103e557507a98b638026bd7">values_container()</a>'.</p>
<p>The method is in O(n), if the order is not important 'unordered_erase(...)' method is faster with an O(1) average complexity. </p>

</div>
</div>
<a id="ae1a43c0ee7ba0748185883de0e879d01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1a43c0ee7ba0748185883de0e879d01">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>When erasing an element, the insert order will be preserved and no holes will be present in the container returned by '<a class="el" href="classtsl_1_1ordered__set.html#a6b0ac6b63103e557507a98b638026bd7">values_container()</a>'.</p>
<p>The method is in O(n), if the order is not important 'unordered_erase(...)' method is faster with an O(1) average complexity. </p>

</div>
</div>
<a id="a64b1e1f6c4a10b446b27fa74bfd4d283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64b1e1f6c4a10b446b27fa74bfd4d283">&#9670;&nbsp;</a></span>erase() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>When erasing an element, the insert order will be preserved and no holes will be present in the container returned by '<a class="el" href="classtsl_1_1ordered__set.html#a6b0ac6b63103e557507a98b638026bd7">values_container()</a>'.</p>
<p>The method is in O(n), if the order is not important 'unordered_erase(...)' method is faster with an O(1) average complexity. </p>

</div>
</div>
<a id="ac10b6934e825cb57c73f0dac6f7c7c73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac10b6934e825cb57c73f0dac6f7c7c73">&#9670;&nbsp;</a></span>erase() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1ordered__set.html#a8190bece5d75ab2799ca333f115cc6f4">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>When erasing an element, the insert order will be preserved and no holes will be present in the container returned by '<a class="el" href="classtsl_1_1ordered__set.html#a6b0ac6b63103e557507a98b638026bd7">values_container()</a>'.</p>
<p>The method is in O(n), if the order is not important 'unordered_erase(...)' method is faster with an O(1) average complexity. </p>

</div>
</div>
<a id="a7cc4a8693220e7513af092a6e4d54e27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cc4a8693220e7513af092a6e4d54e27">&#9670;&nbsp;</a></span>erase() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1ordered__set.html#a8190bece5d75ab2799ca333f115cc6f4">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>When erasing an element, the insert order will be preserved and no holes will be present in the container returned by '<a class="el" href="classtsl_1_1ordered__set.html#a6b0ac6b63103e557507a98b638026bd7">values_container()</a>'.</p>
<p>The method is in O(n), if the order is not important 'unordered_erase(...)' method is faster with an O(1) average complexity.</p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1ordered__set.html#a0177d37fd16de14da45fb8b106980a13">hash_function()</a>(key). Usefull to speed-up the lookup to the value if you already have the hash. </p>

</div>
</div>
<a id="ada9488b9047e0a5cad040cf3b74f83ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada9488b9047e0a5cad040cf3b74f83ec">&#9670;&nbsp;</a></span>erase() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>When erasing an element, the insert order will be preserved and no holes will be present in the container returned by '<a class="el" href="classtsl_1_1ordered__set.html#a6b0ac6b63103e557507a98b638026bd7">values_container()</a>'.</p>
<p>The method is in O(n), if the order is not important 'unordered_erase(...)' method is faster with an O(1) average complexity.</p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="a2a0cd3c395b39468f09c3570bbe47f17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a0cd3c395b39468f09c3570bbe47f17">&#9670;&nbsp;</a></span>erase() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>When erasing an element, the insert order will be preserved and no holes will be present in the container returned by '<a class="el" href="classtsl_1_1ordered__set.html#a6b0ac6b63103e557507a98b638026bd7">values_container()</a>'.</p>
<p>The method is in O(n), if the order is not important 'unordered_erase(...)' method is faster with an O(1) average complexity.</p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1ordered__set.html#a0177d37fd16de14da45fb8b106980a13">hash_function()</a>(key). Usefull to speed-up the lookup to the value if you already have the hash.</p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="adab0ffd41467c4d1034c039926fea912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adab0ffd41467c4d1034c039926fea912">&#9670;&nbsp;</a></span>find() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abb93be16ccaee97295dcb3d2286f17c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb93be16ccaee97295dcb3d2286f17c8">&#9670;&nbsp;</a></span>find() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1ordered__set.html#a0177d37fd16de14da45fb8b106980a13">hash_function()</a>(key). Usefull to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a8c00bb384d0586448c22d79376ac4051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c00bb384d0586448c22d79376ac4051">&#9670;&nbsp;</a></span>find() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af63d187abe1c1dc1e401342bcdede2cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af63d187abe1c1dc1e401342bcdede2cd">&#9670;&nbsp;</a></span>find() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1ordered__set.html#a0177d37fd16de14da45fb8b106980a13">hash_function()</a>(key). Usefull to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a02c3444cfb6a06cb168db22578d81dc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c3444cfb6a06cb168db22578d81dc9">&#9670;&nbsp;</a></span>find() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="accc6083c9c1192016cd0071405a507f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accc6083c9c1192016cd0071405a507f0">&#9670;&nbsp;</a></span>find() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key.</p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1ordered__set.html#a0177d37fd16de14da45fb8b106980a13">hash_function()</a>(key). Usefull to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a8ea337e7a2128b545480be33d89dc5cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ea337e7a2128b545480be33d89dc5cf">&#9670;&nbsp;</a></span>find() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="ac5c13b1e6569ddacba07d97093b5c423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5c13b1e6569ddacba07d97093b5c423">&#9670;&nbsp;</a></span>find() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key.</p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1ordered__set.html#a0177d37fd16de14da45fb8b106980a13">hash_function()</a>(key). Usefull to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="ad88dbc0d34ee749eb88c8d9db5e1c4fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad88dbc0d34ee749eb88c8d9db5e1c4fb">&#9670;&nbsp;</a></span>front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a8460c26d7e313c243ae8ba378416c437">const_reference</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return const_reference to the first element. Requires the container to not be empty. </p>

</div>
</div>
<a id="adb4c60560b937d7260c85d706d4b21b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb4c60560b937d7260c85d706d4b21b8">&#9670;&nbsp;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a56cb8d6b4da9f6833e4a36066672e145">allocator_type</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0177d37fd16de14da45fb8b106980a13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0177d37fd16de14da45fb8b106980a13">&#9670;&nbsp;</a></span>hash_function()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a917144e739de032c41f7abb02155f62c">hasher</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::hash_function </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a73ae6b84e7d515434b44b326eddb9418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73ae6b84e7d515434b44b326eddb9418">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a>, bool&gt; <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1ordered__set.html#ad290a387d9b1c975cce5d91d29b564d3">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a79eb045f9d4f88dee53c41b68cb04ea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79eb045f9d4f88dee53c41b68cb04ea0">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a>, bool&gt; <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#ad290a387d9b1c975cce5d91d29b564d3">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8c9b8292777d5778c8a56788cbd33721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c9b8292777d5778c8a56788cbd33721">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1ordered__set.html#ad290a387d9b1c975cce5d91d29b564d3">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad69a94564252f66399f2924b164cbe71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad69a94564252f66399f2924b164cbe71">&#9670;&nbsp;</a></span>insert() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#ad290a387d9b1c975cce5d91d29b564d3">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a80e21e3ac35b265cf2ff2eebb6545b66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80e21e3ac35b265cf2ff2eebb6545b66">&#9670;&nbsp;</a></span>insert() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a85c11c76775dc7cec5ce7feec2b099c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85c11c76775dc7cec5ce7feec2b099c6">&#9670;&nbsp;</a></span>insert() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classtsl_1_1ordered__set.html#ad290a387d9b1c975cce5d91d29b564d3">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a70b5bf5ee74849fbfe2af8ac0f63ba95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70b5bf5ee74849fbfe2af8ac0f63ba95">&#9670;&nbsp;</a></span>insert_at_position() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a>, bool&gt; <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::insert_at_position </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1ordered__set.html#ad290a387d9b1c975cce5d91d29b564d3">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Insert the value before pos shifting all the elements on the right of pos (including pos) one position to the right.</p>
<p>Amortized linear time-complexity in the distance between pos and <a class="el" href="classtsl_1_1ordered__set.html#a51e27d0dee7772efc44ec2c9456d7d3b">end()</a>. </p>

</div>
</div>
<a id="a0af5289dd180a6b70eb8f8fd3539c722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0af5289dd180a6b70eb8f8fd3539c722">&#9670;&nbsp;</a></span>insert_at_position() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a>, bool&gt; <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::insert_at_position </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#ad290a387d9b1c975cce5d91d29b564d3">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Insert the value before pos shifting all the elements on the right of pos (including pos) one position to the right.</p>
<p>Amortized linear time-complexity in the distance between pos and <a class="el" href="classtsl_1_1ordered__set.html#a51e27d0dee7772efc44ec2c9456d7d3b">end()</a>. </p>

</div>
</div>
<a id="aec9b3316e018b6bb4a1b11f474f37905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec9b3316e018b6bb4a1b11f474f37905">&#9670;&nbsp;</a></span>key_eq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a66536243f870308671743cad80bf8434">key_equal</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::key_eq </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a255ffc4d07c742995ddaa6e2a94dd476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a255ffc4d07c742995ddaa6e2a94dd476">&#9670;&nbsp;</a></span>load_factor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::load_factor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aecc20926ecc35fd9696351f64f6fad8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecc20926ecc35fd9696351f64f6fad8e">&#9670;&nbsp;</a></span>max_bucket_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::max_bucket_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a62c303e8b56f1de355ba7bb2f15d45da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62c303e8b56f1de355ba7bb2f15d45da">&#9670;&nbsp;</a></span>max_load_factor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::max_load_factor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6335e8c9e7de6a07315d767a2c4f7ddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6335e8c9e7de6a07315d767a2c4f7ddc">&#9670;&nbsp;</a></span>max_load_factor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::max_load_factor </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ml</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a19825f1c5612c911892afce4d9d7f223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19825f1c5612c911892afce4d9d7f223">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a39ec112b08bfc835d08770af4e90df1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39ec112b08bfc835d08770af4e90df1f">&#9670;&nbsp;</a></span>mutable_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::mutable_iterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a const_iterator to an iterator. </p>

</div>
</div>
<a id="abc214c68435ebb5e82952c164ad31951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc214c68435ebb5e82952c164ad31951">&#9670;&nbsp;</a></span>nth() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::nth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Requires index &lt;= <a class="el" href="classtsl_1_1ordered__set.html#aa340a26b8fd28baeeae5f4e06030faf8">size()</a>.</p>
<p>Return an iterator to the element at index. Return <a class="el" href="classtsl_1_1ordered__set.html#a51e27d0dee7772efc44ec2c9456d7d3b">end()</a> if index == <a class="el" href="classtsl_1_1ordered__set.html#aa340a26b8fd28baeeae5f4e06030faf8">size()</a>. </p>

</div>
</div>
<a id="a8140877c268625e5a80111138d03614b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8140877c268625e5a80111138d03614b">&#9670;&nbsp;</a></span>nth() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::nth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Requires index &lt;= <a class="el" href="classtsl_1_1ordered__set.html#aa340a26b8fd28baeeae5f4e06030faf8">size()</a>.</p>
<p>Return an iterator to the element at index. Return <a class="el" href="classtsl_1_1ordered__set.html#a51e27d0dee7772efc44ec2c9456d7d3b">end()</a> if index == <a class="el" href="classtsl_1_1ordered__set.html#aa340a26b8fd28baeeae5f4e06030faf8">size()</a>. </p>

</div>
</div>
<a id="ae2d061448410872269cbf2617da8db49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2d061448410872269cbf2617da8db49">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a>&amp; <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classtsl_1_1ordered__set.html#ad290a387d9b1c975cce5d91d29b564d3">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad3fbdf9c812e792bbff41e69bdd68eb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3fbdf9c812e792bbff41e69bdd68eb6">&#9670;&nbsp;</a></span>pop_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aba9174e96e0b66087850d310740c1887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba9174e96e0b66087850d310740c1887">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a6e1307d1650bbde50b3e3b1761488def">reverse_iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afc6c9869db0eea8b9afc48c45359f6bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc6c9869db0eea8b9afc48c45359f6bd">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a4d51ceb41eb392db19dcba27ac7646f2">const_reverse_iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a43f7e3738d25e1a25a10eabb5ed0f804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43f7e3738d25e1a25a10eabb5ed0f804">&#9670;&nbsp;</a></span>rcbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a4d51ceb41eb392db19dcba27ac7646f2">const_reverse_iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::rcbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a14ca05754fb6162b9f4d47083722a714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14ca05754fb6162b9f4d47083722a714">&#9670;&nbsp;</a></span>rcend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a4d51ceb41eb392db19dcba27ac7646f2">const_reverse_iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::rcend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac58d260c2cf387ea01f4ac56dd389c1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac58d260c2cf387ea01f4ac56dd389c1c">&#9670;&nbsp;</a></span>rehash()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::rehash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a596e17766a2a680ce643c82761960c93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a596e17766a2a680ce643c82761960c93">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a6e1307d1650bbde50b3e3b1761488def">reverse_iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a84f66a9ed0ed5d1fe757c5faf8445188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84f66a9ed0ed5d1fe757c5faf8445188">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a4d51ceb41eb392db19dcba27ac7646f2">const_reverse_iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab0a9df6a5bff4ad7fdc1eb0afac5ffa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0a9df6a5bff4ad7fdc1eb0afac5ffa7">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3a0115911c64f13b87e015fb76304776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a0115911c64f13b87e015fb76304776">&#9670;&nbsp;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa340a26b8fd28baeeae5f4e06030faf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa340a26b8fd28baeeae5f4e06030faf8">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b58ba67f8879a171041611e3cf0cb27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b58ba67f8879a171041611e3cf0cb27">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af95469fae633c17d50747abe2593edfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af95469fae633c17d50747abe2593edfe">&#9670;&nbsp;</a></span>unordered_erase() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::unordered_erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Faster erase operation with an O(1) average complexity but it doesn't preserve the insertion order.</p>
<p>If an erasure occurs, the last element of the map will take the place of the erased element. </p>

</div>
</div>
<a id="aedffc8935ca7d9c3e9eccf7b8761ac62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedffc8935ca7d9c3e9eccf7b8761ac62">&#9670;&nbsp;</a></span>unordered_erase() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a5ddb85dd322e204aa32a945da8a70aaf">iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::unordered_erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#a6451524e20af5e0e0e03a78b9a39dbb2">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Faster erase operation with an O(1) average complexity but it doesn't preserve the insertion order.</p>
<p>If an erasure occurs, the last element of the map will take the place of the erased element. </p>

</div>
</div>
<a id="a7a2ff70375bf1b75fbe7957873ccd784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a2ff70375bf1b75fbe7957873ccd784">&#9670;&nbsp;</a></span>unordered_erase() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::unordered_erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1ordered__set.html#a8190bece5d75ab2799ca333f115cc6f4">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Faster erase operation with an O(1) average complexity but it doesn't preserve the insertion order.</p>
<p>If an erasure occurs, the last element of the map will take the place of the erased element. </p>

</div>
</div>
<a id="aa7c74aa9b459b9febeb446fcb5a7e59f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7c74aa9b459b9febeb446fcb5a7e59f">&#9670;&nbsp;</a></span>unordered_erase() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::unordered_erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1ordered__set.html#a8190bece5d75ab2799ca333f115cc6f4">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Faster erase operation with an O(1) average complexity but it doesn't preserve the insertion order.</p>
<p>If an erasure occurs, the last element of the map will take the place of the erased element.</p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1ordered__set.html#a0177d37fd16de14da45fb8b106980a13">hash_function()</a>(key). Usefull to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="aebda9edd78a5103e1a5105defb634af6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebda9edd78a5103e1a5105defb634af6">&#9670;&nbsp;</a></span>unordered_erase() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::unordered_erase </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Faster erase operation with an O(1) average complexity but it doesn't preserve the insertion order.</p>
<p>If an erasure occurs, the last element of the map will take the place of the erased element.</p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="af2aa883c427fd9b1f381e6c3cd1f09fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2aa883c427fd9b1f381e6c3cd1f09fb">&#9670;&nbsp;</a></span>unordered_erase() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a615521b4ff72b2dfbb95e22a434c9952">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::unordered_erase </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Faster erase operation with an O(1) average complexity but it doesn't preserve the insertion order.</p>
<p>If an erasure occurs, the last element of the map will take the place of the erased element.</p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key.</p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1ordered__set.html#a0177d37fd16de14da45fb8b106980a13">hash_function()</a>(key). Usefull to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a6b0ac6b63103e557507a98b638026bd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b0ac6b63103e557507a98b638026bd7">&#9670;&nbsp;</a></span>values_container()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtsl_1_1ordered__set.html#addf17a622dc70f83def6f9f6629dbb46">values_container_type</a>&amp; <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt;::values_container </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the container in which the values are stored. The values are in the same order as the insertion order and are contiguous in the structure, no holes (<a class="el" href="classtsl_1_1ordered__set.html#aa340a26b8fd28baeeae5f4e06030faf8">size()</a> == <a class="el" href="classtsl_1_1ordered__set.html#a6b0ac6b63103e557507a98b638026bd7">values_container()</a>.<a class="el" href="classtsl_1_1ordered__set.html#aa340a26b8fd28baeeae5f4e06030faf8">size()</a>). </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="aafca13b71af5e35082b3e22c01680844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafca13b71af5e35082b3e22c01680844">&#9670;&nbsp;</a></span>operator!=</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad685a66cbb7c59a0923ca7d57a734c27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad685a66cbb7c59a0923ca7d57a734c27">&#9670;&nbsp;</a></span>operator<</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a506164f732a96dfefef194dd47c5459d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a506164f732a96dfefef194dd47c5459d">&#9670;&nbsp;</a></span>operator<=</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa58b43c0c001cea18c9b7d7714b9d85c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa58b43c0c001cea18c9b7d7714b9d85c">&#9670;&nbsp;</a></span>operator==</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a59796ffdc4400bdcb82073c952cdf451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59796ffdc4400bdcb82073c952cdf451">&#9670;&nbsp;</a></span>operator></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a94a17aeb7a1827b4f3cc26552ddb9db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94a17aeb7a1827b4f3cc26552ddb9db0">&#9670;&nbsp;</a></span>operator>=</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5fb2c2dd5207da0a8b606fc11fa6dba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fb2c2dd5207da0a8b606fc11fa6dba8">&#9670;&nbsp;</a></span>swap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>tsl/<a class="el" href="ordered__set_8h_source.html">ordered_set.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
